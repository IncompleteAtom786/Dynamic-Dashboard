import {
  globals_exports,
  useIsomorphicLayoutEffect
} from "./chunk-N6EDIDEK.js";
import {
  NoSsr_default,
  Popper_default
} from "./chunk-P45HQF76.js";
import {
  appearance_default,
  ascending_default,
  band,
  date_default,
  descending_default,
  diverging_default,
  expand_default,
  insideOut_default,
  linear,
  log,
  none_default,
  none_default2,
  number_default,
  ordinal,
  pie_default,
  point,
  pow,
  reverse_default,
  rgbBasis,
  sequential,
  silhouette_default,
  sqrt,
  stack_default,
  threshold,
  time,
  utcTime,
  warnOnce,
  wiggle_default
} from "./chunk-NO54P4Q3.js";
import {
  useThemeProps
} from "./chunk-POOUSAH4.js";
import {
  Typography_default
} from "./chunk-DXMF36AY.js";
import "./chunk-3UOZ5IGB.js";
import "./chunk-PIBW2XQX.js";
import {
  _objectWithoutPropertiesLoose
} from "./chunk-SRCT3FTM.js";
import "./chunk-AACZXOME.js";
import "./chunk-IA4A62E2.js";
import "./chunk-PUETLN54.js";
import "./chunk-BRE2DRTX.js";
import {
  useTheme
} from "./chunk-LYRPXVKL.js";
import "./chunk-JAYAWNVD.js";
import {
  _extends,
  clsx_default,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  ownerWindow,
  ponyfillGlobal_default,
  require_prop_types,
  shouldForwardProp,
  styled_default,
  useControlled,
  useEnhancedEffect_default,
  useForkRef,
  useId,
  useRtl,
  useSlotProps_default
} from "./chunk-X2UZKJLF.js";
import {
  require_jsx_runtime
} from "./chunk-JSQF3CKF.js";
import {
  __toESM,
  require_react
} from "./chunk-JSZTVBPD.js";

// node_modules/@mui/x-charts-pro/Heatmap/Heatmap.js
var React70 = __toESM(require_react());
var import_prop_types18 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsAxis/ChartsAxis.js
var React23 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/CartesianProvider/CartesianProvider.js
var React17 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/models/axis.js
function isBandScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "band";
}
function isPointScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "point";
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/colorScale.js
function getSequentialColorScale(config) {
  if (config.type === "piecewise") {
    return threshold(config.thresholds, config.colors);
  }
  return sequential([config.min ?? 0, config.max ?? 100], config.color);
}
function getOrdinalColorScale(config) {
  if (config.values) {
    return ordinal(config.values, config.colors).unknown(config.unknownColor ?? null);
  }
  return ordinal(config.colors.map((_, index) => index), config.colors).unknown(config.unknownColor ?? null);
}
function getColorScale(config) {
  return config.type === "ordinal" ? getOrdinalColorScale(config) : getSequentialColorScale(config);
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useTicks.js
var React = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/isBandScale.js
function isBandScale(scale) {
  return scale.bandwidth !== void 0;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/isInfinity.js
function isInfinity(v) {
  return typeof v === "number" && !Number.isFinite(v);
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useTicks.js
function getTickNumber(params) {
  const {
    tickMaxStep,
    tickMinStep,
    tickNumber,
    range,
    domain
  } = params;
  const maxTicks = tickMinStep === void 0 ? 999 : Math.floor(Math.abs(domain[1] - domain[0]) / tickMinStep);
  const minTicks = tickMaxStep === void 0 ? 2 : Math.ceil(Math.abs(domain[1] - domain[0]) / tickMaxStep);
  const defaultizedTickNumber = tickNumber ?? Math.floor(Math.abs(range[1] - range[0]) / 50);
  return Math.min(maxTicks, Math.max(minTicks, defaultizedTickNumber));
}
var offsetRatio = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5
};
function useTicks(options) {
  const {
    scale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement = "extremities",
    tickLabelPlacement = "middle"
  } = options;
  return React.useMemo(() => {
    if (isBandScale(scale)) {
      const domain2 = scale.domain();
      if (scale.bandwidth() > 0) {
        const filteredDomain2 = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
        return [...filteredDomain2.map((value) => ({
          value,
          formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick"
          })) ?? `${value}`,
          offset: scale(value) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio[tickPlacement] * scale.step(),
          labelOffset: tickLabelPlacement === "tick" ? 0 : scale.step() * (offsetRatio[tickLabelPlacement] - offsetRatio[tickPlacement])
        })), ...tickPlacement === "extremities" ? [{
          formattedValue: void 0,
          offset: scale.range()[1],
          labelOffset: 0
        }] : []];
      }
      const filteredDomain = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
      return filteredDomain.map((value) => ({
        value,
        formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
          location: "tick"
        })) ?? `${value}`,
        offset: scale(value),
        labelOffset: 0
      }));
    }
    const domain = scale.domain();
    if (domain.some(isInfinity)) {
      return [];
    }
    const ticks = typeof tickInterval === "object" ? tickInterval : scale.ticks(tickNumber);
    return ticks.map((value) => ({
      value,
      formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
        location: "tick"
      })) ?? scale.tickFormat(tickNumber)(value),
      offset: scale(value),
      labelOffset: 0
    }));
  }, [scale, tickInterval, tickNumber, valueFormatter, tickPlacement, tickLabelPlacement]);
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/getScale.js
function getScale(scaleType, domain, range) {
  switch (scaleType) {
    case "log":
      return log(domain, range);
    case "pow":
      return pow(domain, range);
    case "sqrt":
      return sqrt(domain, range);
    case "time":
      return time(domain, range);
    case "utc":
      return utcTime(domain, range);
    default:
      return linear(domain, range);
  }
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/CartesianProvider/zoom.js
var zoomScaleRange = (scaleRange, zoomRange) => {
  const rangeGap = scaleRange[1] - scaleRange[0];
  const zoomGap = zoomRange[1] - zoomRange[0];
  const min = scaleRange[0] - zoomRange[0] * rangeGap / zoomGap;
  const max = scaleRange[1] + (100 - zoomRange[1]) * rangeGap / zoomGap;
  return [min, max];
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/CartesianProvider/getAxisExtremum.js
var axisExtremumCallback = (acc, chartType, axis, getters, axisIndex, formattedSeries, getFilters) => {
  var _a;
  const getter = getters[chartType];
  const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
  const [minChartTypeData, maxChartTypeData] = (getter == null ? void 0 : getter({
    series,
    axis,
    axisIndex,
    isDefaultAxis: axisIndex === 0,
    getFilters
  })) ?? [Infinity, -Infinity];
  const [minData, maxData] = acc;
  return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
};
var getAxisExtremum = (axis, getters, axisIndex, formattedSeries, getFilters) => {
  const charTypes = Object.keys(getters);
  const extremums = charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, axisIndex, formattedSeries, getFilters), [Infinity, -Infinity]);
  if (Number.isNaN(extremums[0]) || Number.isNaN(extremums[1])) {
    return [Infinity, -Infinity];
  }
  return extremums;
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/computeAxisValue.js
function getRange(drawingArea, axisDirection, axis) {
  if (axisDirection === "rotation") {
    const {
      startAngle = 0,
      endAngle = startAngle + 360
    } = axis;
    return axis.reverse ? [Math.PI * startAngle / 180, Math.PI * endAngle / 180] : [Math.PI * endAngle / 180, Math.PI * startAngle / 180];
  }
  if (axisDirection === "radius") {
    const {
      minRadius = 0,
      maxRadius = Math.min(drawingArea.width, drawingArea.height) / 2
    } = axis;
    return [minRadius, maxRadius];
  }
  const range = axisDirection === "x" ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];
  return axis.reverse ? [range[1], range[0]] : range;
}
var isDateData = (data) => (data == null ? void 0 : data[0]) instanceof Date;
function createDateFormatter(axis, range) {
  const timeScale = time(axis.data, range);
  return (v, {
    location
  }) => location === "tick" ? timeScale.tickFormat(axis.tickNumber)(v) : `${v.toLocaleString()}`;
}
var DEFAULT_CATEGORY_GAP_RATIO = 0.2;
var DEFAULT_BAR_GAP_RATIO = 0.1;
function computeAxisValue({
  drawingArea,
  formattedSeries,
  axis: allAxis,
  extremumGetters,
  axisDirection,
  zoomData,
  zoomOptions,
  getFilters
}) {
  const completeAxis = {};
  allAxis.forEach((eachAxis, axisIndex) => {
    const axis = eachAxis;
    const zoomOption = zoomOptions == null ? void 0 : zoomOptions[axis.id];
    const zoom = zoomData == null ? void 0 : zoomData.find(({
      axisId
    }) => axisId === axis.id);
    const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];
    const range = getRange(drawingArea, axisDirection, axis);
    const [minData, maxData] = getAxisExtremum(
      axis,
      extremumGetters,
      axisIndex,
      formattedSeries,
      zoom === void 0 && !zoomOption ? getFilters : void 0
      // Do not apply filtering if zoom is already defined.
    );
    const data = axis.data ?? [];
    if (isBandScaleConfig(axis)) {
      const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;
      const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;
      const scaleRange = axisDirection === "y" ? [range[1], range[0]] : range;
      const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({
        categoryGapRatio,
        barGapRatio
      }, axis, {
        data,
        scale: band(axis.data, zoomedRange2).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (isPointScaleConfig(axis)) {
      const scaleRange = axisDirection === "y" ? [...range].reverse() : range;
      const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({}, axis, {
        data,
        scale: point(axis.data, zoomedRange2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (axis.scaleType === "band" || axis.scaleType === "point") {
      return;
    }
    const scaleType = axis.scaleType ?? "linear";
    const axisExtremums = [axis.min ?? minData, axis.max ?? maxData];
    const rawTickNumber = getTickNumber(_extends({}, axis, {
      range,
      domain: axisExtremums
    }));
    const tickNumber = rawTickNumber / ((zoomRange[1] - zoomRange[0]) / 100);
    const zoomedRange = zoomScaleRange(range, zoomRange);
    const scale = getScale(scaleType, axisExtremums, zoomedRange).nice(rawTickNumber);
    const [minDomain, maxDomain] = scale.domain();
    const domain = [axis.min ?? minDomain, axis.max ?? maxDomain];
    completeAxis[axis.id] = _extends({}, axis, {
      data,
      scaleType,
      scale: scale.domain(domain),
      tickNumber,
      colorScale: axis.colorMap && getColorScale(axis.colorMap)
    });
  });
  return {
    axis: completeAxis,
    axisIds: allAxis.map(({
      id
    }) => id)
  };
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useDrawingArea.js
var React4 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/DrawingProvider.js
var React3 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useChartDimensions.js
var React2 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/constants/index.js
var DEFAULT_X_AXIS_KEY = "DEFAULT_X_AXIS_KEY";
var DEFAULT_Y_AXIS_KEY = "DEFAULT_Y_AXIS_KEY";
var DEFAULT_MARGINS = {
  top: 50,
  bottom: 50,
  left: 50,
  right: 50
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useChartDimensions.js
var useChartDimensions = (width, height, margin) => {
  const defaultizedMargin = _extends({}, DEFAULT_MARGINS, margin);
  const drawingArea = React2.useMemo(() => ({
    left: defaultizedMargin.left,
    top: defaultizedMargin.top,
    right: defaultizedMargin.right,
    bottom: defaultizedMargin.bottom,
    width: Math.max(0, width - defaultizedMargin.left - defaultizedMargin.right),
    height: Math.max(0, height - defaultizedMargin.top - defaultizedMargin.bottom)
  }), [width, height, defaultizedMargin.top, defaultizedMargin.bottom, defaultizedMargin.left, defaultizedMargin.right]);
  return drawingArea;
};
var useChartDimensions_default = useChartDimensions;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/DrawingProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var DrawingContext = React3.createContext({
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
  height: 300,
  width: 400,
  chartId: "",
  isPointInside: () => false
});
if (true) {
  DrawingContext.displayName = "DrawingContext";
}
var SvgContext = React3.createContext({
  isInitialized: false,
  data: {
    current: null
  }
});
if (true) {
  SvgContext.displayName = "SvgContext";
}
function DrawingProvider(props) {
  const {
    width,
    height,
    margin,
    svgRef,
    children
  } = props;
  const drawingArea = useChartDimensions_default(width, height, margin);
  const chartId = useId();
  const isPointInside = React3.useCallback(({
    x,
    y
  }, options) => {
    if ((options == null ? void 0 : options.targetElement) && (options == null ? void 0 : options.targetElement.closest("[data-drawing-container]"))) {
      return true;
    }
    const isInsideX = x >= drawingArea.left - 1 && x <= drawingArea.left + drawingArea.width;
    const isInsideY = y >= drawingArea.top - 1 && y <= drawingArea.top + drawingArea.height;
    if ((options == null ? void 0 : options.direction) === "x") {
      return isInsideX;
    }
    if ((options == null ? void 0 : options.direction) === "y") {
      return isInsideY;
    }
    return isInsideX && isInsideY;
  }, [drawingArea]);
  const value = React3.useMemo(() => _extends({
    chartId: chartId ?? ""
  }, drawingArea, {
    isPointInside
  }), [chartId, drawingArea, isPointInside]);
  const refValue = React3.useMemo(() => ({
    isInitialized: true,
    data: svgRef
  }), [svgRef]);
  return (0, import_jsx_runtime.jsx)(SvgContext.Provider, {
    value: refValue,
    children: (0, import_jsx_runtime.jsx)(DrawingContext.Provider, {
      value,
      children
    })
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useDrawingArea.js
function useDrawingArea() {
  const {
    left,
    top,
    width,
    height,
    bottom,
    right,
    isPointInside
  } = React4.useContext(DrawingContext);
  return React4.useMemo(() => ({
    left,
    top,
    width,
    height,
    bottom,
    right,
    isPointInside
  }), [height, left, top, width, bottom, right, isPointInside]);
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useSeries.js
var React15 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/defaultizeColor.js
var DEFAULT_COLORS = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
function defaultizeColor(series, seriesIndex, colors = DEFAULT_COLORS) {
  if (series.type === "pie") {
    return _extends({}, series, {
      data: series.data.map((d, index) => _extends({
        color: colors[index % colors.length]
      }, d))
    });
  }
  return _extends({
    color: colors[seriesIndex % colors.length]
  }, series);
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/SeriesProvider/processSeries.js
var preprocessSeries = ({
  series,
  colors,
  seriesFormatters,
  dataset
}) => {
  const seriesGroups = {};
  series.forEach((seriesData, seriesIndex) => {
    var _a;
    const {
      id = `auto-generated-id-${seriesIndex}`,
      type
    } = seriesData;
    if (seriesGroups[type] === void 0) {
      seriesGroups[type] = {
        series: {},
        seriesOrder: []
      };
    }
    if (((_a = seriesGroups[type]) == null ? void 0 : _a.series[id]) !== void 0) {
      throw new Error(`MUI X: series' id "${id}" is not unique.`);
    }
    seriesGroups[type].series[id] = _extends({
      id
    }, defaultizeColor(seriesData, seriesIndex, colors));
    seriesGroups[type].seriesOrder.push(id);
  });
  const formattedSeries = {};
  Object.keys(seriesFormatters).forEach((type) => {
    var _a;
    const group = seriesGroups[type];
    if (group !== void 0) {
      formattedSeries[type] = ((_a = seriesFormatters[type]) == null ? void 0 : _a.call(seriesFormatters, group, dataset)) ?? seriesGroups[type];
    }
  });
  return formattedSeries;
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/SeriesProvider/SeriesProvider.js
var React14 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/colorPalettes/colorPalettes.js
var blueberryTwilightPaletteLight = ["#02B2AF", "#2E96FF", "#B800D8", "#60009B", "#2731C8", "#03008D"];
var blueberryTwilightPaletteDark = ["#02B2AF", "#72CCFF", "#DA00FF", "#9001CB", "#2E96FF", "#3B48E0"];
var blueberryTwilightPalette = (mode) => mode === "dark" ? blueberryTwilightPaletteDark : blueberryTwilightPaletteLight;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/SeriesProvider/SeriesContext.js
var React5 = __toESM(require_react());
var SeriesContext = React5.createContext({
  isInitialized: false,
  data: {}
});
if (true) {
  SeriesContext.displayName = "SeriesContext";
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/PluginProvider.js
var React7 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/PluginContext.js
var React6 = __toESM(require_react());
var PluginContext = React6.createContext({
  isInitialized: false,
  data: {
    colorProcessors: {},
    seriesFormatters: {},
    xExtremumGetters: {},
    yExtremumGetters: {},
    rotationExtremumGetters: {},
    radiusExtremumGetters: {}
  }
});
if (true) {
  PluginContext.displayName = "PluginContext";
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/BarChart/extremums.js
var createResult = (data, direction) => {
  if (direction === "x") {
    return {
      x: data,
      y: null
    };
  }
  return {
    x: null,
    y: data
  };
};
var getBaseExtremum = (params) => {
  var _a;
  const {
    axis,
    getFilters,
    isDefaultAxis
  } = params;
  const filter = getFilters == null ? void 0 : getFilters({
    currentAxisId: axis.id,
    isDefaultAxis
  });
  const data = filter ? (_a = axis.data) == null ? void 0 : _a.filter((_, i2) => filter({
    x: null,
    y: null
  }, i2)) : axis.data;
  const minX = Math.min(...data ?? []);
  const maxX = Math.max(...data ?? []);
  return [minX, maxX];
};
var getValueExtremum = (direction) => (params) => {
  const {
    series,
    axis,
    getFilters,
    isDefaultAxis
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;
    return yAxisId === axis.id || isDefaultAxis && yAxisId === void 0;
  }).reduce((acc, seriesId) => {
    const {
      stackedData
    } = series[seriesId];
    const filter = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
      seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
    });
    const [seriesMin, seriesMax] = (stackedData == null ? void 0 : stackedData.reduce((seriesAcc, values, index) => {
      if (filter && (!filter(createResult(values[0], direction), index) || !filter(createResult(values[1], direction), index))) {
        return seriesAcc;
      }
      return [Math.min(...values, seriesAcc[0]), Math.max(...values, seriesAcc[1])];
    }, [Infinity, -Infinity])) ?? [Infinity, -Infinity];
    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
  }, [Infinity, -Infinity]);
};
var getExtremumX = (params) => {
  const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
  if (isHorizontal) {
    return getValueExtremum("x")(params);
  }
  return getBaseExtremum(params);
};
var getExtremumY = (params) => {
  const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
  if (isHorizontal) {
    return getBaseExtremum(params);
  }
  return getValueExtremum("y")(params);
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/stackSeries.js
var StackOrder = {
  /**
   * Series order such that the earliest series (according to the maximum value) is at the bottom.
   * */
  appearance: appearance_default,
  /**
   *  Series order such that the smallest series (according to the sum of values) is at the bottom.
   * */
  ascending: ascending_default,
  /**
   * Series order such that the largest series (according to the sum of values) is at the bottom.
   */
  descending: descending_default,
  /**
   * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs—Geometry & Aesthetics by Byron & Wattenberg for more information.
   */
  insideOut: insideOut_default,
  /**
   * Given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
   */
  none: none_default2,
  /**
   * Reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
   */
  reverse: reverse_default
};
var StackOffset = {
  /**
   * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
   * */
  expand: expand_default,
  /**
   * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
   * */
  diverging: diverging_default,
  /**
   * Applies a zero baseline.
   * */
  none: none_default,
  /**
   * Shifts the baseline down such that the center of the streamgraph is always at zero.
   * */
  silhouette: silhouette_default,
  /**
   * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.
   * */
  wiggle: wiggle_default
};
var getStackingGroups = (params) => {
  const {
    series,
    seriesOrder,
    defaultStrategy
  } = params;
  const stackingGroups = [];
  const stackIndex = {};
  seriesOrder.forEach((id) => {
    const {
      stack,
      stackOrder,
      stackOffset
    } = series[id];
    if (stack === void 0) {
      stackingGroups.push({
        ids: [id],
        stackingOrder: StackOrder.none,
        stackingOffset: StackOffset.none
      });
    } else if (stackIndex[stack] === void 0) {
      stackIndex[stack] = stackingGroups.length;
      stackingGroups.push({
        ids: [id],
        stackingOrder: StackOrder[stackOrder ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOrder) ?? "none"],
        stackingOffset: StackOffset[stackOffset ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOffset) ?? "diverging"]
      });
    } else {
      stackingGroups[stackIndex[stack]].ids.push(id);
      if (stackOrder !== void 0) {
        stackingGroups[stackIndex[stack]].stackingOrder = StackOrder[stackOrder];
      }
      if (stackOffset !== void 0) {
        stackingGroups[stackIndex[stack]].stackingOffset = StackOffset[stackOffset];
      }
    }
  });
  return stackingGroups;
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/defaultizeValueFormatter.js
function defaultizeValueFormatter(series, defaultValueFormatter) {
  const defaultizedSeries = {};
  Object.keys(series).forEach((seriesId) => {
    defaultizedSeries[seriesId] = _extends({}, series[seriesId], {
      valueFormatter: series[seriesId].valueFormatter ?? defaultValueFormatter
    });
  });
  return defaultizedSeries;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/BarChart/formatter.js
var formatter = (params, dataset) => {
  const {
    seriesOrder,
    series
  } = params;
  const stackingGroups = getStackingGroups(params);
  const d3Dataset = dataset ?? [];
  seriesOrder.forEach((id) => {
    const data = series[id].data;
    if (data !== void 0) {
      data.forEach((value, index) => {
        if (d3Dataset.length <= index) {
          d3Dataset.push({
            [id]: value
          });
        } else {
          d3Dataset[index][id] = value;
        }
      });
    } else if (dataset === void 0) {
      throw new Error([`MUI X: bar series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
    }
  });
  const completedSeries = {};
  stackingGroups.forEach((stackingGroup) => {
    const {
      ids,
      stackingOffset,
      stackingOrder
    } = stackingGroup;
    const stackedSeries = stack_default().keys(ids.map((id) => {
      const dataKey = series[id].dataKey;
      return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
    })).value((d, key) => d[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach((id, index) => {
      const dataKey = series[id].dataKey;
      completedSeries[id] = _extends({
        layout: "vertical"
      }, series[id], {
        data: dataKey ? dataset.map((data) => {
          const value = data[dataKey];
          if (typeof value !== "number") {
            if (true) {
              if (value !== null) {
                warnOnce([`MUI X: your dataset key "${dataKey}" is used for plotting bars, but contains nonnumerical elements.`, "Bar plots only support numbers and null values."]);
              }
            }
            return 0;
          }
          return value;
        }) : series[id].data,
        stackedData: stackedSeries[index].map(([a, b]) => [a, b])
      });
    });
  });
  return {
    seriesOrder,
    stackingGroups,
    series: defaultizeValueFormatter(completedSeries, (v) => v == null ? "" : v.toLocaleString())
  };
};
var formatter_default = formatter;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/BarChart/getColor.js
var getColor = (series, xAxis, yAxis) => {
  const verticalLayout = series.layout === "vertical";
  const bandColorScale = verticalLayout ? xAxis == null ? void 0 : xAxis.colorScale : yAxis == null ? void 0 : yAxis.colorScale;
  const valueColorScale = verticalLayout ? yAxis == null ? void 0 : yAxis.colorScale : xAxis == null ? void 0 : xAxis.colorScale;
  const bandValues = verticalLayout ? xAxis == null ? void 0 : xAxis.data : yAxis == null ? void 0 : yAxis.data;
  if (valueColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : valueColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (bandColorScale && bandValues) {
    return (dataIndex) => {
      const value = bandValues[dataIndex];
      const color = value === null ? series.color : bandColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  return () => series.color;
};
var getColor_default = getColor;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/BarChart/plugin.js
var plugin = {
  seriesType: "bar",
  seriesFormatter: formatter_default,
  colorProcessor: getColor_default,
  xExtremumGetter: getExtremumX,
  yExtremumGetter: getExtremumY
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ScatterChart/extremums.js
var mergeMinMax = (acc, val) => {
  return [Math.min(acc[0], val[0]), Math.max(acc[1], val[1])];
};
var getExtremumX2 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis,
    getFilters
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const axisId = series[seriesId].xAxisId ?? series[seriesId].xAxisKey;
    return axisId === axis.id || axisId === void 0 && isDefaultAxis;
  }).reduce((acc, seriesId) => {
    var _a;
    const filter = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
      seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
    });
    const seriesMinMax = (_a = series[seriesId].data) == null ? void 0 : _a.reduce((accSeries, d, dataIndex) => {
      if (filter && !filter(d, dataIndex)) {
        return accSeries;
      }
      return mergeMinMax(accSeries, [d.x, d.x]);
    }, [Infinity, -Infinity]);
    return mergeMinMax(acc, seriesMinMax ?? [Infinity, -Infinity]);
  }, [Infinity, -Infinity]);
};
var getExtremumY2 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis,
    getFilters
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const axisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;
    return axisId === axis.id || axisId === void 0 && isDefaultAxis;
  }).reduce((acc, seriesId) => {
    var _a;
    const filter = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
      seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
    });
    const seriesMinMax = (_a = series[seriesId].data) == null ? void 0 : _a.reduce((accSeries, d, dataIndex) => {
      if (filter && !filter(d, dataIndex)) {
        return accSeries;
      }
      return mergeMinMax(accSeries, [d.y, d.y]);
    }, [Infinity, -Infinity]);
    return mergeMinMax(acc, seriesMinMax ?? [Infinity, -Infinity]);
  }, [Infinity, -Infinity]);
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ScatterChart/formatter.js
var formatter2 = ({
  series,
  seriesOrder
}, dataset) => {
  const completeSeries = Object.fromEntries(Object.entries(series).map(([seriesId, seriesData]) => {
    const datasetKeys = seriesData == null ? void 0 : seriesData.datasetKeys;
    const missingKeys = ["x", "y", "id"].filter((key) => typeof (datasetKeys == null ? void 0 : datasetKeys[key]) !== "string");
    if ((seriesData == null ? void 0 : seriesData.datasetKeys) && missingKeys.length > 0) {
      throw new Error([`MUI X: scatter series with id='${seriesId}' has incomplete datasetKeys.`, `Properties ${missingKeys.map((key) => `"${key}"`).join(", ")} are missing.`].join("\n"));
    }
    const data = !datasetKeys ? seriesData.data ?? [] : (dataset == null ? void 0 : dataset.map((d) => {
      return {
        x: d[datasetKeys.x],
        y: d[datasetKeys.y],
        z: datasetKeys.z && d[datasetKeys.z],
        id: d[datasetKeys.id]
      };
    })) ?? [];
    return [seriesId, _extends({}, seriesData, {
      data,
      valueFormatter: seriesData.valueFormatter ?? ((v) => `(${v.x}, ${v.y})`)
    })];
  }));
  return {
    series: completeSeries,
    seriesOrder
  };
};
var formatter_default2 = formatter2;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ScatterChart/getColor.js
var getColor2 = (series, xAxis, yAxis, zAxis) => {
  const zColorScale = zAxis == null ? void 0 : zAxis.colorScale;
  const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
  const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
  if (zColorScale) {
    return (dataIndex) => {
      var _a, _b;
      if (((_a = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _a[dataIndex]) !== void 0) {
        const color2 = zColorScale((_b = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _b[dataIndex]);
        if (color2 !== null) {
          return color2;
        }
      }
      const value = series.data[dataIndex];
      const color = value === null ? series.color : zColorScale(value.z);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (yColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : yColorScale(value.y);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : xColorScale(value.x);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  return () => series.color;
};
var getColor_default2 = getColor2;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ScatterChart/plugin.js
var plugin2 = {
  seriesType: "scatter",
  seriesFormatter: formatter_default2,
  colorProcessor: getColor_default2,
  xExtremumGetter: getExtremumX2,
  yExtremumGetter: getExtremumY2
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/LineChart/extremums.js
var getExtremumX3 = (params) => {
  const {
    axis
  } = params;
  const minX = Math.min(...axis.data ?? []);
  const maxX = Math.max(...axis.data ?? []);
  return [minX, maxX];
};
function getSeriesExtremums(getValues, stackedData, filter) {
  return stackedData.reduce((seriesAcc, stackedValue, index) => {
    const [base, value] = getValues(stackedValue);
    if (filter && (!filter({
      y: base,
      x: null
    }, index) || !filter({
      y: value,
      x: null
    }, index))) {
      return seriesAcc;
    }
    return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];
  }, [Infinity, -Infinity]);
}
var getExtremumY3 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis,
    getFilters
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;
    return yAxisId === axis.id || isDefaultAxis && yAxisId === void 0;
  }).reduce((acc, seriesId) => {
    const {
      area,
      stackedData
    } = series[seriesId];
    const isArea = area !== void 0;
    const filter = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
      seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
    });
    const getValues = isArea && axis.scaleType !== "log" && typeof series[seriesId].baseline !== "string" ? (d) => d : (d) => [d[1], d[1]];
    const seriesExtremums = getSeriesExtremums(getValues, stackedData, filter);
    const [seriesMin, seriesMax] = seriesExtremums;
    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
  }, [Infinity, -Infinity]);
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/LineChart/formatter.js
var formatter3 = (params, dataset) => {
  const {
    seriesOrder,
    series
  } = params;
  const stackingGroups = getStackingGroups(_extends({}, params, {
    defaultStrategy: {
      stackOffset: "none"
    }
  }));
  const d3Dataset = dataset ?? [];
  seriesOrder.forEach((id) => {
    const data = series[id].data;
    if (data !== void 0) {
      data.forEach((value, index) => {
        if (d3Dataset.length <= index) {
          d3Dataset.push({
            [id]: value
          });
        } else {
          d3Dataset[index][id] = value;
        }
      });
    } else if (dataset === void 0 && true) {
      throw new Error([`MUI X: line series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
    }
  });
  const completedSeries = {};
  stackingGroups.forEach((stackingGroup) => {
    const {
      ids,
      stackingOrder,
      stackingOffset
    } = stackingGroup;
    const stackedSeries = stack_default().keys(ids.map((id) => {
      const dataKey = series[id].dataKey;
      return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
    })).value((d, key) => d[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach((id, index) => {
      const dataKey = series[id].dataKey;
      completedSeries[id] = _extends({}, series[id], {
        data: dataKey ? dataset.map((data) => {
          const value = data[dataKey];
          if (typeof value !== "number") {
            if (true) {
              if (value !== null) {
                warnOnce([`MUI X: Your dataset key "${dataKey}" is used for plotting line, but contains nonnumerical elements.`, "Line plots only support numbers and null values."]);
              }
            }
            return null;
          }
          return value;
        }) : series[id].data,
        stackedData: stackedSeries[index].map(([a, b]) => [a, b])
      });
    });
  });
  return {
    seriesOrder,
    stackingGroups,
    series: defaultizeValueFormatter(completedSeries, (v) => v == null ? "" : v.toLocaleString())
  };
};
var formatter_default3 = formatter3;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/LineChart/getColor.js
var getColor3 = (series, xAxis, yAxis) => {
  const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
  const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
  if (yColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : yColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      var _a;
      const value = (_a = xAxis.data) == null ? void 0 : _a[dataIndex];
      const color = value === null ? series.color : xColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  return () => series.color;
};
var getColor_default3 = getColor3;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/LineChart/plugin.js
var plugin3 = {
  seriesType: "line",
  colorProcessor: getColor_default3,
  seriesFormatter: formatter_default3,
  xExtremumGetter: getExtremumX3,
  yExtremumGetter: getExtremumY3
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/getLabel.js
function getLabel(value, location) {
  return typeof value === "function" ? value(location) : value;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/PieChart/formatter.js
var getSortingComparator = (comparator = "none") => {
  if (typeof comparator === "function") {
    return comparator;
  }
  switch (comparator) {
    case "none":
      return null;
    case "desc":
      return (a, b) => b - a;
    case "asc":
      return (a, b) => a - b;
    default:
      return null;
  }
};
var formatter4 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  const defaultizedSeries = {};
  seriesOrder.forEach((seriesId) => {
    const arcs = pie_default().startAngle(2 * Math.PI * (series[seriesId].startAngle ?? 0) / 360).endAngle(2 * Math.PI * (series[seriesId].endAngle ?? 360) / 360).padAngle(2 * Math.PI * (series[seriesId].paddingAngle ?? 0) / 360).sortValues(getSortingComparator(series[seriesId].sortingValues ?? "none"))(series[seriesId].data.map((piePoint) => piePoint.value));
    defaultizedSeries[seriesId] = _extends({
      valueFormatter: (item) => item.value.toLocaleString()
    }, series[seriesId], {
      data: series[seriesId].data.map((item, index) => _extends({}, item, {
        id: item.id ?? `auto-generated-pie-id-${seriesId}-${index}`
      }, arcs[index])).map((item, index) => {
        var _a, _b;
        return _extends({}, item, {
          formattedValue: ((_b = (_a = series[seriesId]).valueFormatter) == null ? void 0 : _b.call(_a, _extends({}, item, {
            label: getLabel(item.label, "arc")
          }), {
            dataIndex: index
          })) ?? item.value.toLocaleString()
        });
      })
    });
  });
  return {
    seriesOrder,
    series: defaultizedSeries
  };
};
var formatter_default4 = formatter4;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/PieChart/getColor.js
var getColor4 = (series) => {
  return (dataIndex) => {
    return series.data[dataIndex].color;
  };
};
var getColor_default4 = getColor4;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/PieChart/plugin.js
var plugin4 = {
  seriesType: "pie",
  colorProcessor: getColor_default4,
  seriesFormatter: formatter_default4
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/mergePlugins.js
var defaultPlugins = [plugin, plugin2, plugin3, plugin4];
function mergePlugins(plugins) {
  const defaultizedPlugins = plugins ?? defaultPlugins;
  const seriesFormatters = {};
  const colorProcessors = {};
  const xExtremumGetters = {};
  const yExtremumGetters = {};
  const rotationExtremumGetters = {};
  const radiusExtremumGetters = {};
  for (let i2 = 0; i2 < defaultizedPlugins.length; i2 += 1) {
    const plugin6 = defaultizedPlugins[i2];
    const seriesType = plugin6.seriesType;
    seriesFormatters[seriesType] = plugin6.seriesFormatter;
    colorProcessors[seriesType] = plugin6.colorProcessor;
    if (plugin6.xExtremumGetter) {
      xExtremumGetters[seriesType] = plugin6.xExtremumGetter;
    }
    if (plugin6.yExtremumGetter) {
      yExtremumGetters[seriesType] = plugin6.yExtremumGetter;
    }
    if (plugin6.rotationExtremumGetter) {
      rotationExtremumGetters[seriesType] = plugin6.rotationExtremumGetter;
    }
    if (plugin6.radiusExtremumGetter) {
      radiusExtremumGetters[seriesType] = plugin6.radiusExtremumGetter;
    }
  }
  return {
    seriesFormatters,
    colorProcessors,
    xExtremumGetters,
    yExtremumGetters,
    rotationExtremumGetters,
    radiusExtremumGetters
  };
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/PluginProvider.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function PluginProvider(props) {
  const {
    children,
    plugins
  } = props;
  const formattedSeries = React7.useMemo(() => ({
    isInitialized: true,
    data: mergePlugins(plugins)
  }), [plugins]);
  return (0, import_jsx_runtime2.jsx)(PluginContext.Provider, {
    value: formattedSeries,
    children
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/useColorProcessor.js
var React8 = __toESM(require_react());
function useColorProcessor(seriesType) {
  const {
    isInitialized,
    data
  } = React8.useContext(PluginContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  if (!seriesType) {
    return data.colorProcessors;
  }
  return data.colorProcessors[seriesType];
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/useSeriesFormatter.js
var React9 = __toESM(require_react());
function useSeriesFormatter(seriesType) {
  const {
    isInitialized,
    data
  } = React9.useContext(PluginContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  if (!seriesType) {
    return data.seriesFormatters;
  }
  return data.seriesFormatters[seriesType];
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/useXExtremumGetter.js
var React10 = __toESM(require_react());
function useXExtremumGetter(seriesType) {
  const {
    isInitialized,
    data
  } = React10.useContext(PluginContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  if (!seriesType) {
    return data.xExtremumGetters;
  }
  return data.xExtremumGetters[seriesType];
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/useYExtremumGetter.js
var React11 = __toESM(require_react());
function useYExtremumGetter(seriesType) {
  const {
    isInitialized,
    data
  } = React11.useContext(PluginContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  if (!seriesType) {
    return data.yExtremumGetters;
  }
  return data.yExtremumGetters[seriesType];
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/useRadiusExtremumGetter.js
var React12 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/PluginProvider/useRotationExtremumGetter.js
var React13 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/SeriesProvider/SeriesProvider.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function SeriesProvider(props) {
  const {
    series,
    dataset,
    colors = blueberryTwilightPalette,
    children
  } = props;
  const seriesFormatters = useSeriesFormatter();
  const theme = useTheme();
  const formattedSeries = React14.useMemo(() => ({
    isInitialized: true,
    data: preprocessSeries({
      series,
      colors: typeof colors === "function" ? colors(theme.palette.mode) : colors,
      seriesFormatters,
      dataset
    })
  }), [series, colors, theme.palette.mode, seriesFormatters, dataset]);
  return (0, import_jsx_runtime3.jsx)(SeriesContext.Provider, {
    value: formattedSeries,
    children
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useSeries.js
function useSeries() {
  const {
    isInitialized,
    data
  } = React15.useContext(SeriesContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the series ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/CartesianProvider/CartesianContext.js
var React16 = __toESM(require_react());
var CartesianContext = React16.createContext({
  isInitialized: false,
  data: {
    xAxis: {},
    yAxis: {},
    xAxisIds: [],
    yAxisIds: []
  }
});
if (true) {
  CartesianContext.displayName = "CartesianContext";
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/CartesianProvider/CartesianProvider.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/CartesianProvider/useCartesianContext.js
var React18 = __toESM(require_react());
var useCartesianContext = () => {
  const {
    data
  } = React18.useContext(CartesianContext);
  return data;
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsXAxis/ChartsXAxis.js
var React21 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsAxis/axisClasses.js
function getAxisUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxis", slot);
}
var axisClasses = generateUtilityClasses("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right"]);

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/components/AxisSharedComponents.js
var AxisRoot = styled_default("g", {
  name: "MuiChartsAxis",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => ({
  [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.label}`]: _extends({}, theme.typography.body1, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.line}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  },
  [`& .${axisClasses.tick}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges"
  }
}));

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsText/ChartsText.js
var React19 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/domUtils.js
function isSsr() {
  return typeof window === "undefined";
}
var stringCache = {
  widthCache: {},
  cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
var MEASUREMENT_SPAN_ID = "mui_measurement_span";
function autoCompleteStyle(name, value) {
  if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
    return `${value}px`;
  }
  return value;
}
function camelToMiddleLine(text) {
  const strs = text.split("");
  const formatStrs = strs.reduce((result, entry) => {
    if (entry === entry.toUpperCase()) {
      return [...result, "-", entry.toLowerCase()];
    }
    return [...result, entry];
  }, []);
  return formatStrs.join("");
}
var getStyleString = (style) => Object.keys(style).sort().reduce((result, s) => `${result}${camelToMiddleLine(s)}:${autoCompleteStyle(s, style[s])};`, "");
var domCleanTimeout;
var getStringSize = (text, style = {}) => {
  if (text === void 0 || text === null || isSsr()) {
    return {
      width: 0,
      height: 0
    };
  }
  const str = `${text}`;
  const styleString = getStyleString(style);
  const cacheKey = `${str}-${styleString}`;
  if (stringCache.widthCache[cacheKey]) {
    return stringCache.widthCache[cacheKey];
  }
  try {
    let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (measurementSpan === null) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    const measurementSpanStyle = _extends({}, SPAN_STYLE, style);
    Object.keys(measurementSpanStyle).map((styleKey) => {
      measurementSpan.style[camelToMiddleLine(styleKey)] = autoCompleteStyle(styleKey, measurementSpanStyle[styleKey]);
      return styleKey;
    });
    measurementSpan.textContent = str;
    const rect = measurementSpan.getBoundingClientRect();
    const result = {
      width: rect.width,
      height: rect.height
    };
    stringCache.widthCache[cacheKey] = result;
    if (stringCache.cacheCount + 1 > MAX_CACHE_NUM) {
      stringCache.cacheCount = 0;
      stringCache.widthCache = {};
    } else {
      stringCache.cacheCount += 1;
    }
    if (domCleanTimeout) {
      clearTimeout(domCleanTimeout);
    }
    domCleanTimeout = setTimeout(() => {
      measurementSpan.textContent = "";
    }, 0);
    return result;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/getWordsByLines.js
function getWordsByLines({
  style,
  needsComputation,
  text
}) {
  return text.split("\n").map((subText) => _extends({
    text: subText
  }, needsComputation ? getStringSize(subText, style) : {
    width: 0,
    height: 0
  }));
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsText/ChartsText.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var _excluded = ["x", "y", "style", "text", "ownerState"];
var _excluded2 = ["angle", "textAnchor", "dominantBaseline"];
function ChartsText(props) {
  const {
    x,
    y,
    style: styleProps,
    text
  } = props, textProps = _objectWithoutPropertiesLoose(props, _excluded);
  const _ref = styleProps ?? {}, {
    angle,
    textAnchor,
    dominantBaseline
  } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded2);
  const wordsByLines = React19.useMemo(() => getWordsByLines({
    style,
    needsComputation: text.includes("\n"),
    text
  }), [style, text]);
  let startDy;
  switch (dominantBaseline) {
    case "hanging":
      startDy = 0;
      break;
    case "central":
      startDy = (wordsByLines.length - 1) / 2 * -wordsByLines[0].height;
      break;
    default:
      startDy = (wordsByLines.length - 1) * -wordsByLines[0].height;
      break;
  }
  const transforms = [];
  if (angle) {
    transforms.push(`rotate(${angle}, ${x}, ${y})`);
  }
  return (0, import_jsx_runtime5.jsx)("text", _extends({}, textProps, {
    transform: transforms.length > 0 ? transforms.join(" ") : void 0,
    x,
    y,
    textAnchor,
    dominantBaseline,
    style,
    children: wordsByLines.map((line, index) => (0, import_jsx_runtime5.jsx)("tspan", {
      x,
      dy: `${index === 0 ? startDy : wordsByLines[0].height}px`,
      dominantBaseline,
      children: line.text
    }, index))
  }));
}
true ? ChartsText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types.default.bool,
  ownerState: import_prop_types.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types.default.object,
  /**
   * Text displayed.
   */
  text: import_prop_types.default.string.isRequired
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/geometry.js
var ANGLE_APPROX = 5;
function getMinXTranslation(width, height, angle = 0) {
  if (true) {
    if (angle > 90 && angle < -90) {
      warnOnce([`MUI X: It seems you applied an angle larger than 90° or smaller than -90° to an axis text.`, `This could cause some text overlapping.`, `If you encounter a use case where it's needed, please open an issue.`]);
    }
  }
  const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
  if (standardAngle < ANGLE_APPROX) {
    return width;
  }
  if (standardAngle > 90 - ANGLE_APPROX) {
    return height;
  }
  const radAngle = standardAngle * Math.PI / 180;
  const angleSwich = Math.atan2(height, width);
  if (radAngle < angleSwich) {
    return width / Math.cos(radAngle);
  }
  return height / Math.sin(radAngle);
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useMounted.js
var React20 = __toESM(require_react());
function useMounted(defer = false) {
  const [mountedState, setMountedState] = React20.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React20.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsXAxis/ChartsXAxis.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _excluded3 = ["scale", "tickNumber", "reverse"];
var useUtilityClasses = (ownerState) => {
  const {
    classes,
    position
  } = ownerState;
  const slots = {
    root: ["root", "directionX", position],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
function addLabelDimension(xTicks, {
  tickLabelStyle: style,
  tickLabelInterval,
  reverse,
  isMounted
}) {
  const withDimension = xTicks.map((tick) => {
    if (!isMounted || tick.formattedValue === void 0) {
      return _extends({}, tick, {
        width: 0,
        height: 0
      });
    }
    const tickSizes = getWordsByLines({
      style,
      needsComputation: true,
      text: tick.formattedValue
    });
    return _extends({}, tick, {
      width: Math.max(...tickSizes.map((size) => size.width)),
      height: Math.max(tickSizes.length * tickSizes[0].height)
    });
  });
  if (typeof tickLabelInterval === "function") {
    return withDimension.map((item, index) => _extends({}, item, {
      skipLabel: !tickLabelInterval(item.value, index)
    }));
  }
  let currentTextLimit = 0;
  let previousTextLimit = 0;
  const direction = reverse ? -1 : 1;
  return withDimension.map((item, labelIndex) => {
    const {
      width,
      offset,
      labelOffset,
      height
    } = item;
    const distance = getMinXTranslation(width, height, style == null ? void 0 : style.angle);
    const textPosition = offset + labelOffset;
    const gapRatio = 1.2;
    currentTextLimit = textPosition - direction * (gapRatio * distance) / 2;
    if (labelIndex > 0 && direction * currentTextLimit < direction * previousTextLimit) {
      return _extends({}, item, {
        skipLabel: true
      });
    }
    previousTextLimit = textPosition + direction * (gapRatio * distance) / 2;
    return item;
  });
}
var XAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsXAxis",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var defaultProps = {
  position: "bottom",
  disableLine: false,
  disableTicks: false,
  tickSize: 6
};
function ChartsXAxis(inProps) {
  const {
    xAxisIds,
    xAxis
  } = useCartesianContext();
  const _xAxis = xAxis[inProps.axisId ?? xAxisIds[0]], {
    scale: xScale,
    tickNumber,
    reverse
  } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded3);
  const isMounted = useMounted();
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsXAxis"
  });
  const defaultizedProps = _extends({}, defaultProps, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    tickLabelStyle,
    label,
    labelStyle,
    tickFontSize,
    labelFontSize,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickInterval,
    tickLabelInterval,
    tickPlacement,
    tickLabelPlacement,
    sx
  } = defaultizedProps;
  const theme = useTheme();
  const classes = useUtilityClasses(_extends({}, defaultizedProps, {
    theme
  }));
  const {
    left,
    top,
    width,
    height,
    isPointInside
  } = useDrawingArea();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const positionSign = position === "bottom" ? 1 : -1;
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "hanging" : "auto",
        fontSize: tickFontSize ?? 12
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const xTicks = useTicks({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement
  });
  const xTicksWithDimension = addLabelDimension(xTicks, {
    tickLabelStyle: axisTickLabelProps.style,
    tickLabelInterval,
    reverse,
    isMounted
  });
  const labelRefPoint = {
    x: left + width / 2,
    y: positionSign * (tickSize + 22)
  };
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({
        fontSize: labelFontSize ?? 14,
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "hanging" : "auto"
      }, labelStyle)
    },
    ownerState: {}
  });
  const domain = xScale.domain();
  const ordinalAxis = isBandScale(xScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
    return null;
  }
  return (0, import_jsx_runtime6.jsxs)(XAxisRoot, {
    transform: `translate(0, ${position === "bottom" ? top + height : top})`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime6.jsx)(Line, _extends({
      x1: left,
      x2: left + width,
      className: classes.line
    }, slotProps == null ? void 0 : slotProps.axisLine)), xTicksWithDimension.map(({
      formattedValue,
      offset,
      labelOffset,
      skipLabel
    }, index) => {
      const xTickLabel = labelOffset ?? 0;
      const yTickLabel = positionSign * (tickSize + 3);
      const showTick = isPointInside({
        x: offset,
        y: -1
      }, {
        direction: "x"
      });
      const showTickLabel = isPointInside({
        x: offset + xTickLabel,
        y: -1
      }, {
        direction: "x"
      });
      return (0, import_jsx_runtime6.jsxs)("g", {
        transform: `translate(${offset}, 0)`,
        className: classes.tickContainer,
        children: [!disableTicks && showTick && (0, import_jsx_runtime6.jsx)(Tick, _extends({
          y2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && showTickLabel && (0, import_jsx_runtime6.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel
        }, axisTickLabelProps, {
          text: formattedValue.toString()
        }))]
      }, index);
    }), label && (0, import_jsx_runtime6.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime6.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsXAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types2.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types2.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types2.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types2.default.string,
  /**
   * The font size of the axis label.
   * @default 14
   * @deprecated Consider using `labelStyle.fontSize` instead.
   */
  labelFontSize: import_prop_types2.default.number,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types2.default.object,
  /**
   * Position of the axis.
   */
  position: import_prop_types2.default.oneOf(["bottom", "top"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types2.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types2.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types2.default.string,
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object]),
  /**
   * The font size of the axis ticks text.
   * @default 12
   * @deprecated Consider using `tickLabelStyle.fontSize` instead.
   */
  tickFontSize: import_prop_types2.default.number,
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types2.default.oneOfType([import_prop_types2.default.oneOf(["auto"]), import_prop_types2.default.array, import_prop_types2.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types2.default.oneOfType([import_prop_types2.default.oneOf(["auto"]), import_prop_types2.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types2.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types2.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types2.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types2.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types2.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types2.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types2.default.number
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsYAxis/ChartsYAxis.js
var React22 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded4 = ["scale", "tickNumber"];
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    position
  } = ownerState;
  const slots = {
    root: ["root", "directionY", position],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var YAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsYAxis",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var defaultProps2 = {
  position: "left",
  disableLine: false,
  disableTicks: false,
  tickFontSize: 12,
  labelFontSize: 14,
  tickSize: 6
};
function ChartsYAxis(inProps) {
  const {
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const _yAxis = yAxis[inProps.axisId ?? yAxisIds[0]], {
    scale: yScale,
    tickNumber
  } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded4);
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsYAxis"
  });
  const defaultizedProps = _extends({}, defaultProps2, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    tickFontSize,
    label,
    labelFontSize,
    labelStyle,
    tickLabelStyle,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickLabelInterval,
    sx
  } = defaultizedProps;
  const theme = useTheme();
  const isRtl = useRtl();
  const classes = useUtilityClasses2(_extends({}, defaultizedProps, {
    theme
  }));
  const {
    left,
    top,
    width,
    height,
    isPointInside
  } = useDrawingArea();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const yTicks = useTicks({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickPlacement,
    tickLabelPlacement,
    tickInterval
  });
  const positionSign = position === "right" ? 1 : -1;
  const labelRefPoint = {
    x: positionSign * (tickFontSize + tickSize + 10),
    y: top + height / 2
  };
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const revertAnchor = !isRtl && position === "right" || isRtl && position !== "right";
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({
        fontSize: tickFontSize,
        textAnchor: revertAnchor ? "start" : "end",
        dominantBaseline: "central"
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({
        fontSize: labelFontSize,
        angle: positionSign * 90,
        textAnchor: "middle",
        dominantBaseline: "auto"
      }, labelStyle)
    },
    ownerState: {}
  });
  const lineSlotProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLine,
    additionalProps: {
      strokeLinecap: "square"
    },
    ownerState: {}
  });
  const domain = yScale.domain();
  const ordinalAxis = isBandScale(yScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
    return null;
  }
  return (0, import_jsx_runtime7.jsxs)(YAxisRoot, {
    transform: `translate(${position === "right" ? left + width : left}, 0)`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime7.jsx)(Line, _extends({
      y1: top,
      y2: top + height,
      className: classes.line
    }, lineSlotProps)), yTicks.map(({
      formattedValue,
      offset,
      labelOffset,
      value
    }, index) => {
      const xTickLabel = positionSign * (tickSize + 2);
      const yTickLabel = labelOffset;
      const skipLabel = typeof tickLabelInterval === "function" && !(tickLabelInterval == null ? void 0 : tickLabelInterval(value, index));
      const showLabel = isPointInside({
        x: -1,
        y: offset
      }, {
        direction: "y"
      });
      if (!showLabel) {
        return null;
      }
      return (0, import_jsx_runtime7.jsxs)("g", {
        transform: `translate(0, ${offset})`,
        className: classes.tickContainer,
        children: [!disableTicks && (0, import_jsx_runtime7.jsx)(Tick, _extends({
          x2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && (0, import_jsx_runtime7.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel,
          text: formattedValue.toString()
        }, axisTickLabelProps))]
      }, index);
    }), label && (0, import_jsx_runtime7.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime7.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsYAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types3.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types3.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types3.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types3.default.string,
  /**
   * The font size of the axis label.
   * @default 14
   * @deprecated Consider using `labelStyle.fontSize` instead.
   */
  labelFontSize: import_prop_types3.default.number,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types3.default.object,
  /**
   * Position of the axis.
   */
  position: import_prop_types3.default.oneOf(["left", "right"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types3.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types3.default.string,
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),
  /**
   * The font size of the axis ticks text.
   * @default 12
   * @deprecated Consider using `tickLabelStyle.fontSize` instead.
   */
  tickFontSize: import_prop_types3.default.number,
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["auto"]), import_prop_types3.default.array, import_prop_types3.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["auto"]), import_prop_types3.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types3.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types3.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types3.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types3.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types3.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types3.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types3.default.number
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsAxis/ChartsAxis.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var getAxisId = (propsValue, defaultAxisId) => {
  if (propsValue == null) {
    return null;
  }
  if (typeof propsValue === "object") {
    return propsValue.axisId ?? defaultAxisId ?? null;
  }
  return propsValue;
};
var mergeProps = (axisConfig, slots, slotProps) => {
  return typeof axisConfig === "object" ? _extends({}, axisConfig, {
    slots: _extends({}, slots, axisConfig == null ? void 0 : axisConfig.slots),
    slotProps: _extends({}, slotProps, axisConfig == null ? void 0 : axisConfig.slotProps)
  }) : {
    slots,
    slotProps
  };
};
function ChartsAxis(props) {
  const {
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    slots,
    slotProps
  } = props;
  const {
    xAxis,
    xAxisIds,
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const leftId = getAxisId(leftAxis === void 0 ? yAxisIds[0] : leftAxis, yAxisIds[0]);
  const bottomId = getAxisId(bottomAxis === void 0 ? xAxisIds[0] : bottomAxis, xAxisIds[0]);
  const topId = getAxisId(topAxis, xAxisIds[0]);
  const rightId = getAxisId(rightAxis, yAxisIds[0]);
  if (topId !== null && !xAxis[topId]) {
    throw new Error([`MUI X: id used for top axis "${topId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
  }
  if (leftId !== null && !yAxis[leftId]) {
    throw new Error([`MUI X: id used for left axis "${leftId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
  }
  if (rightId !== null && !yAxis[rightId]) {
    throw new Error([`MUI X: id used for right axis "${rightId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
  }
  if (bottomId !== null && !xAxis[bottomId]) {
    throw new Error([`MUI X: id used for bottom axis "${bottomId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
  }
  const topAxisProps = mergeProps(topAxis, slots, slotProps);
  const bottomAxisProps = mergeProps(bottomAxis, slots, slotProps);
  const leftAxisProps = mergeProps(leftAxis, slots, slotProps);
  const rightAxisProps = mergeProps(rightAxis, slots, slotProps);
  return (0, import_jsx_runtime8.jsxs)(React23.Fragment, {
    children: [topId && (0, import_jsx_runtime8.jsx)(ChartsXAxis, _extends({}, topAxisProps, {
      position: "top",
      axisId: topId
    })), bottomId && (0, import_jsx_runtime8.jsx)(ChartsXAxis, _extends({}, bottomAxisProps, {
      position: "bottom",
      axisId: bottomId
    })), leftId && (0, import_jsx_runtime8.jsx)(ChartsYAxis, _extends({}, leftAxisProps, {
      position: "left",
      axisId: leftId
    })), rightId && (0, import_jsx_runtime8.jsx)(ChartsYAxis, _extends({}, rightAxisProps, {
      position: "right",
      axisId: rightId
    }))]
  });
}
true ? ChartsAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types4.default.oneOfType([import_prop_types4.default.object, import_prop_types4.default.string]),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types4.default.oneOfType([import_prop_types4.default.object, import_prop_types4.default.string]),
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types4.default.oneOfType([import_prop_types4.default.object, import_prop_types4.default.string]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types4.default.object,
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types4.default.oneOfType([import_prop_types4.default.object, import_prop_types4.default.string])
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltip.js
var React34 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/InteractionProvider.js
var React24 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var InteractionContext = React24.createContext({
  item: null,
  axis: {
    x: null,
    y: null
  },
  useVoronoiInteraction: false,
  dispatch: () => null
});
if (true) {
  InteractionContext.displayName = "InteractionContext";
}
var dataReducer = (prevState, action) => {
  switch (action.type) {
    case "enterItem":
      return _extends({}, prevState, {
        item: action.data
      });
    case "exitChart":
      if (prevState.item === null && prevState.axis.x === null && prevState.axis.y === null) {
        return prevState;
      }
      return _extends({}, prevState, {
        axis: {
          x: null,
          y: null
        },
        item: null
      });
    case "updateVoronoiUsage":
      return _extends({}, prevState, {
        useVoronoiInteraction: action.useVoronoiInteraction
      });
    case "leaveItem":
      if (prevState.item === null || Object.keys(action.data).some((key) => action.data[key] !== prevState.item[key])) {
        return prevState;
      }
      return _extends({}, prevState, {
        item: null
      });
    case "updateAxis":
      if (action.data.x === prevState.axis.x && action.data.y === prevState.axis.y) {
        return prevState;
      }
      return _extends({}, prevState, {
        axis: action.data
      });
    default:
      return prevState;
  }
};
function InteractionProvider(props) {
  const {
    children
  } = props;
  const [data, dispatch] = React24.useReducer(dataReducer, {
    item: null,
    axis: {
      x: null,
      y: null
    },
    useVoronoiInteraction: false
  });
  const value = React24.useMemo(() => _extends({}, data, {
    dispatch
  }), [data]);
  return (0, import_jsx_runtime9.jsx)(InteractionContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/utils.js
var React29 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useChartId.js
var React25 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useAxis.js
function useXAxis(identifier) {
  const {
    xAxis,
    xAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : xAxisIds[identifier ?? 0];
  return xAxis[id];
}
function useYAxis(identifier) {
  const {
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : yAxisIds[identifier ?? 0];
  return yAxis[id];
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useScale.js
function useXScale(identifier) {
  const axis = useXAxis(identifier);
  return axis.scale;
}
function useYScale(identifier) {
  const axis = useYAxis(identifier);
  return axis.scale;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useColorScale.js
var React27 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/ZAxisContextProvider.js
var React26 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var ZAxisContext = React26.createContext({
  zAxis: {},
  zAxisIds: []
});
if (true) {
  ZAxisContext.displayName = "ZAxisContext";
}
function ZAxisContextProvider(props) {
  const {
    zAxis: inZAxis,
    dataset,
    children
  } = props;
  const zAxis = React26.useMemo(() => inZAxis == null ? void 0 : inZAxis.map((axisConfig) => {
    const dataKey = axisConfig.dataKey;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return axisConfig;
    }
    if (dataset === void 0) {
      throw new Error("MUI X: z-axis uses `dataKey` but no `dataset` is provided.");
    }
    return _extends({}, axisConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  }), [inZAxis, dataset]);
  const value = React26.useMemo(() => {
    const allZAxis = (zAxis == null ? void 0 : zAxis.map((axis, index) => _extends({
      id: `defaultized-z-axis-${index}`
    }, axis))) ?? [];
    const completedZAxis = {};
    allZAxis.forEach((axis) => {
      completedZAxis[axis.id] = _extends({}, axis, {
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" && axis.data ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap.type === "continuous" ? _extends({
          min: axis.min,
          max: axis.max
        }, axis.colorMap) : axis.colorMap))
      });
    });
    return {
      zAxis: completedZAxis,
      zAxisIds: allZAxis.map(({
        id
      }) => id)
    };
  }, [zAxis]);
  return (0, import_jsx_runtime10.jsx)(ZAxisContext.Provider, {
    value,
    children
  });
}
true ? ZAxisContextProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types5.default.node,
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types5.default.arrayOf(import_prop_types5.default.shape({
    colorMap: import_prop_types5.default.oneOfType([import_prop_types5.default.shape({
      colors: import_prop_types5.default.arrayOf(import_prop_types5.default.string).isRequired,
      type: import_prop_types5.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types5.default.string,
      values: import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.instanceOf(Date), import_prop_types5.default.number, import_prop_types5.default.string]).isRequired)
    }), import_prop_types5.default.shape({
      color: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.string.isRequired), import_prop_types5.default.func]).isRequired,
      max: import_prop_types5.default.oneOfType([import_prop_types5.default.instanceOf(Date), import_prop_types5.default.number]),
      min: import_prop_types5.default.oneOfType([import_prop_types5.default.instanceOf(Date), import_prop_types5.default.number]),
      type: import_prop_types5.default.oneOf(["continuous"]).isRequired
    }), import_prop_types5.default.shape({
      colors: import_prop_types5.default.arrayOf(import_prop_types5.default.string).isRequired,
      thresholds: import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.instanceOf(Date), import_prop_types5.default.number]).isRequired).isRequired,
      type: import_prop_types5.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types5.default.array,
    dataKey: import_prop_types5.default.string,
    id: import_prop_types5.default.string,
    max: import_prop_types5.default.number,
    min: import_prop_types5.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useColorScale.js
function useZColorScale(identifier) {
  var _a;
  const {
    zAxis,
    zAxisIds
  } = React27.useContext(ZAxisContext);
  const id = typeof identifier === "string" ? identifier : zAxisIds[identifier ?? 0];
  return (_a = zAxis[id]) == null ? void 0 : _a.colorScale;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useSvgRef.js
var React28 = __toESM(require_react());
function useSvgRef() {
  const {
    isInitialized,
    data
  } = React28.useContext(SvgContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the svg ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/utils.js
function generateVirtualElement(mousePosition) {
  if (mousePosition === null) {
    return {
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        toJSON: () => ""
      })
    };
  }
  const {
    x,
    y
  } = mousePosition;
  const boundingBox = {
    width: 0,
    height: 0,
    x,
    y,
    top: y,
    right: x,
    bottom: y,
    left: x
  };
  return {
    getBoundingClientRect: () => _extends({}, boundingBox, {
      toJSON: () => JSON.stringify(boundingBox)
    })
  };
}
function useMouseTracker() {
  const svgRef = useSvgRef();
  const [mousePosition, setMousePosition] = React29.useState(null);
  React29.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleOut = (event) => {
      if (event.pointerType !== "mouse") {
        setMousePosition(null);
      }
    };
    const handleMove = (event) => {
      setMousePosition({
        x: event.clientX,
        y: event.clientY,
        height: event.height,
        pointerType: event.pointerType
      });
    };
    element.addEventListener("pointerdown", handleMove);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointerup", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleMove);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointerup", handleOut);
    };
  }, [svgRef]);
  return mousePosition;
}
function getTooltipHasData(trigger, displayedData) {
  if (trigger === "item") {
    return displayedData !== null;
  }
  const hasAxisXData = displayedData.x !== null;
  const hasAxisYData = displayedData.y !== null;
  return hasAxisXData || hasAxisYData;
}
function utcFormatter(v) {
  if (v instanceof Date) {
    return v.toUTCString();
  }
  return v.toLocaleString();
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/ChartsItemTooltipContent.js
var React31 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsItemTooltipContent.js
var React30 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/chartsTooltipClasses.js
function getChartsTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiChartsTooltip", slot);
}
var chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markCell", "labelCell", "valueCell"]);

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltipTable.js
var ChartsTooltipPaper = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Container",
  overridesResolver: (props, styles) => styles.paper
})(({
  theme
}) => ({
  boxShadow: theme.shadows[1],
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  transition: theme.transitions.create("box-shadow"),
  borderRadius: theme.shape.borderRadius
}));
var ChartsTooltipTable = styled_default("table", {
  name: "MuiChartsTooltip",
  slot: "Table",
  overridesResolver: (props, styles) => styles.table
})(({
  theme
}) => ({
  borderSpacing: 0,
  "& thead td": {
    borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`
  }
}));
var ChartsTooltipRow = styled_default("tr", {
  name: "MuiChartsTooltip",
  slot: "Row",
  overridesResolver: (props, styles) => styles.row
})(({
  theme
}) => ({
  "tr:first-of-type& td": {
    paddingTop: theme.spacing(1)
  },
  "tr:last-of-type& td": {
    paddingBottom: theme.spacing(1)
  }
}));
var ChartsTooltipCell = styled_default("td", {
  name: "MuiChartsTooltip",
  slot: "Cell",
  overridesResolver: (props, styles) => styles.cell
})(({
  theme
}) => ({
  verticalAlign: "middle",
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${chartsTooltipClasses.labelCell}`]: {
    paddingLeft: theme.spacing(1)
  },
  [`&.${chartsTooltipClasses.valueCell}`]: {
    paddingLeft: theme.spacing(4),
    color: (theme.vars || theme).palette.text.primary
  },
  "td:first-of-type&": {
    paddingLeft: theme.spacing(2)
  },
  "td:last-of-type&": {
    paddingRight: theme.spacing(2)
  }
}));
var ChartsTooltipMark = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Mark",
  overridesResolver: (props, styles) => styles.mark,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "color"
})(({
  theme,
  color
}) => ({
  width: theme.spacing(1),
  height: theme.spacing(1),
  borderRadius: "50%",
  boxShadow: theme.shadows[1],
  backgroundColor: color,
  borderColor: (theme.vars || theme).palette.background.paper,
  border: `solid ${(theme.vars || theme).palette.background.paper} ${theme.spacing(0.25)}`,
  boxSizing: "content-box"
}));

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsItemTooltipContent.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
function DefaultChartsItemTooltipContent(props) {
  var _a;
  const {
    series,
    itemData,
    sx,
    classes,
    getColor: getColor6
  } = props;
  if (itemData.dataIndex === void 0 || !series.data[itemData.dataIndex]) {
    return null;
  }
  const {
    displayedLabel,
    color
  } = series.type === "pie" ? {
    color: getColor6(itemData.dataIndex),
    displayedLabel: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  } : {
    color: getColor6(itemData.dataIndex),
    displayedLabel: getLabel(series.label, "tooltip")
  };
  const value = series.type === "pie" ? _extends({}, series.data[itemData.dataIndex], {
    label: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  }) : series.data[itemData.dataIndex];
  const formattedValue = (_a = series.valueFormatter) == null ? void 0 : _a.call(series, value, {
    dataIndex: itemData.dataIndex
  });
  return (0, import_jsx_runtime11.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.paper,
    children: (0, import_jsx_runtime11.jsx)(ChartsTooltipTable, {
      className: classes.table,
      children: (0, import_jsx_runtime11.jsx)("tbody", {
        children: (0, import_jsx_runtime11.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime11.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.markCell, classes.cell),
            children: (0, import_jsx_runtime11.jsx)(ChartsTooltipMark, {
              color,
              className: classes.mark
            })
          }), (0, import_jsx_runtime11.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            children: displayedLabel
          }), (0, import_jsx_runtime11.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            children: formattedValue
          })]
        })
      })
    })
  });
}
true ? DefaultChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types6.default.object.isRequired,
  /**
   * Get the color of the item with index `dataIndex`.
   * @param {number} dataIndex The data index of the item.
   * @returns {string} The color to display.
   */
  getColor: import_prop_types6.default.func.isRequired,
  /**
   * The data used to identify the triggered item.
   */
  itemData: import_prop_types6.default.shape({
    dataIndex: import_prop_types6.default.number,
    seriesId: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]).isRequired,
    type: import_prop_types6.default.oneOf(["bar", "line", "pie", "scatter"]).isRequired
  }).isRequired,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types6.default.object.isRequired,
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object])
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/ChartsItemTooltipContent.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
function ChartsItemTooltipContent(props) {
  var _a;
  const {
    content,
    itemData,
    sx,
    classes,
    contentProps
  } = props;
  const series = useSeries()[itemData.type].series[itemData.seriesId];
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React31.useContext(ZAxisContext);
  const colorProcessors = useColorProcessor();
  const xAxisId = series.xAxisId ?? series.xAxisKey ?? xAxisIds[0];
  const yAxisId = series.yAxisId ?? series.yAxisKey ?? yAxisIds[0];
  const zAxisId = series.zAxisId ?? series.zAxisKey ?? zAxisIds[0];
  const getColor6 = ((_a = colorProcessors[series.type]) == null ? void 0 : _a.call(colorProcessors, series, xAxisId && xAxis[xAxisId], yAxisId && yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
  const Content = content ?? DefaultChartsItemTooltipContent;
  const chartTooltipContentProps = useSlotProps_default({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      itemData,
      series,
      sx,
      classes,
      getColor: getColor6
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime12.jsx)(Content, _extends({}, chartTooltipContentProps));
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/ChartsAxisTooltipContent.js
var React33 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var React32 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/configInit.js
var instance;
var CartesianSeriesTypes = class {
  constructor() {
    this.types = /* @__PURE__ */ new Set();
    if (instance) {
      throw new Error("You can only create one instance!");
    }
    instance = this.types;
  }
  addType(value) {
    this.types.add(value);
  }
  getTypes() {
    return this.types;
  }
};
var cartesianSeriesTypes = new CartesianSeriesTypes();
cartesianSeriesTypes.addType("bar");
cartesianSeriesTypes.addType("line");
cartesianSeriesTypes.addType("scatter");

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/isCartesian.js
function isCartesianSeriesType(seriesType) {
  return cartesianSeriesTypes.getTypes().has(seriesType);
}
function isCartesianSeries(series) {
  return isCartesianSeriesType(series.type);
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
function DefaultChartsAxisTooltipContent(props) {
  const {
    series,
    axis,
    dataIndex,
    axisValue,
    sx,
    classes
  } = props;
  if (dataIndex == null) {
    return null;
  }
  const axisFormatter = axis.valueFormatter ?? ((v) => axis.scaleType === "utc" ? utcFormatter(v) : v.toLocaleString());
  return (0, import_jsx_runtime13.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.paper,
    children: (0, import_jsx_runtime13.jsxs)(ChartsTooltipTable, {
      className: classes.table,
      children: [axisValue != null && !axis.hideTooltip && (0, import_jsx_runtime13.jsx)("thead", {
        children: (0, import_jsx_runtime13.jsx)(ChartsTooltipRow, {
          children: (0, import_jsx_runtime13.jsx)(ChartsTooltipCell, {
            colSpan: 3,
            children: (0, import_jsx_runtime13.jsx)(Typography_default, {
              children: axisFormatter(axisValue, {
                location: "tooltip"
              })
            })
          })
        })
      }), (0, import_jsx_runtime13.jsx)("tbody", {
        children: series.filter(isCartesianSeries).map(({
          id,
          label,
          valueFormatter,
          data,
          getColor: getColor6
        }) => {
          const formattedValue = valueFormatter(data[dataIndex] ?? null, {
            dataIndex
          });
          if (formattedValue == null) {
            return null;
          }
          const formattedLabel = getLabel(label, "tooltip");
          const color = getColor6(dataIndex);
          return (0, import_jsx_runtime13.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [(0, import_jsx_runtime13.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.markCell, classes.cell),
              children: color && (0, import_jsx_runtime13.jsx)(ChartsTooltipMark, {
                color,
                className: classes.mark
              })
            }), (0, import_jsx_runtime13.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              children: formattedLabel ? (0, import_jsx_runtime13.jsx)(Typography_default, {
                children: formattedLabel
              }) : null
            }), (0, import_jsx_runtime13.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              children: (0, import_jsx_runtime13.jsx)(Typography_default, {
                children: formattedValue
              })
            })]
          }, id);
        })
      })]
    })
  });
}
true ? DefaultChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The properties of the triggered axis.
   */
  axis: import_prop_types7.default.object.isRequired,
  /**
   * Data identifying the triggered axis.
   */
  axisData: import_prop_types7.default.shape({
    x: import_prop_types7.default.shape({
      index: import_prop_types7.default.number,
      value: import_prop_types7.default.oneOfType([import_prop_types7.default.instanceOf(Date), import_prop_types7.default.number, import_prop_types7.default.string]).isRequired
    }),
    y: import_prop_types7.default.shape({
      index: import_prop_types7.default.number,
      value: import_prop_types7.default.oneOfType([import_prop_types7.default.instanceOf(Date), import_prop_types7.default.number, import_prop_types7.default.string]).isRequired
    })
  }).isRequired,
  /**
   * The value associated to the current mouse position.
   */
  axisValue: import_prop_types7.default.oneOfType([import_prop_types7.default.instanceOf(Date), import_prop_types7.default.number, import_prop_types7.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types7.default.object.isRequired,
  /**
   * The index of the data item triggered.
   */
  dataIndex: import_prop_types7.default.number,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types7.default.arrayOf(import_prop_types7.default.object).isRequired,
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object])
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/ChartsAxisTooltipContent.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
function ChartsAxisTooltipContent(props) {
  const {
    content,
    contentProps,
    axisData,
    sx,
    classes
  } = props;
  const isXaxis = axisData.x && axisData.x.index !== -1;
  const dataIndex = isXaxis ? axisData.x && axisData.x.index : axisData.y && axisData.y.index;
  const axisValue = isXaxis ? axisData.x && axisData.x.value : axisData.y && axisData.y.value;
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const {
    zAxisIds,
    zAxis
  } = React33.useContext(ZAxisContext);
  const series = useSeries();
  const colorProcessors = useColorProcessor();
  const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
  const relevantSeries = React33.useMemo(() => {
    const rep = [];
    Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
      series[seriesType].seriesOrder.forEach((seriesId) => {
        var _a;
        const item = series[seriesType].series[seriesId];
        const providedXAxisId = item.xAxisId ?? item.xAxisKey;
        const providedYAxisId = item.yAxisId ?? item.yAxisKey;
        const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
        if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
          const seriesToAdd = series[seriesType].series[seriesId];
          const xAxisId = providedXAxisId ?? xAxisIds[0];
          const yAxisId = providedYAxisId ?? yAxisIds[0];
          const zAxisId = seriesToAdd.zAxisId ?? seriesToAdd.zAxisKey ?? zAxisIds[0];
          const getColor6 = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd, xAxis[xAxisId], yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
          rep.push(_extends({}, seriesToAdd, {
            getColor: getColor6
          }));
        }
      });
    });
    return rep;
  }, [USED_AXIS_ID, colorProcessors, isXaxis, series, xAxis, xAxisIds, yAxis, yAxisIds, zAxis, zAxisIds]);
  const relevantAxis = React33.useMemo(() => {
    return isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];
  }, [USED_AXIS_ID, isXaxis, xAxis, yAxis]);
  const Content = content ?? DefaultChartsAxisTooltipContent;
  const chartTooltipContentProps = useSlotProps_default({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      axisData,
      series: relevantSeries,
      axis: relevantAxis,
      dataIndex,
      axisValue,
      sx,
      classes
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime14.jsx)(Content, _extends({}, chartTooltipContentProps));
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltip.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var useUtilityClasses3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    table: ["table"],
    row: ["row"],
    cell: ["cell"],
    mark: ["mark"],
    markCell: ["markCell"],
    labelCell: ["labelCell"],
    valueCell: ["valueCell"]
  };
  return composeClasses(slots, getChartsTooltipUtilityClass, classes);
};
var ChartsTooltipRoot = styled_default(Popper_default, {
  name: "MuiChartsTooltip",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  pointerEvents: "none",
  zIndex: theme.zIndex.modal
}));
function ChartsTooltip(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsTooltip"
  });
  const {
    trigger = "axis",
    itemContent,
    axisContent,
    slots,
    slotProps
  } = props;
  const mousePosition = useMouseTracker();
  const {
    item,
    axis
  } = React34.useContext(InteractionContext);
  const displayedData = trigger === "item" ? item : axis;
  const tooltipHasData = getTooltipHasData(trigger, displayedData);
  const popperOpen = mousePosition !== null && tooltipHasData;
  const classes = useUtilityClasses3({
    classes: props.classes
  });
  const PopperComponent = (slots == null ? void 0 : slots.popper) ?? ChartsTooltipRoot;
  const popperProps = useSlotProps_default({
    elementType: PopperComponent,
    externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
    additionalProps: {
      open: popperOpen,
      placement: (mousePosition == null ? void 0 : mousePosition.pointerType) === "mouse" ? "right-start" : "top",
      anchorEl: generateVirtualElement(mousePosition),
      modifiers: [{
        name: "offset",
        options: {
          offset: [0, (mousePosition == null ? void 0 : mousePosition.pointerType) === "touch" ? 40 - mousePosition.height : 0]
        }
      }]
    },
    ownerState: {}
  });
  if (trigger === "none") {
    return null;
  }
  return (0, import_jsx_runtime15.jsx)(NoSsr_default, {
    children: popperOpen && (0, import_jsx_runtime15.jsx)(PopperComponent, _extends({}, popperProps, {
      className: classes.root,
      children: trigger === "item" ? (0, import_jsx_runtime15.jsx)(ChartsItemTooltipContent, {
        itemData: displayedData,
        content: (slots == null ? void 0 : slots.itemContent) ?? itemContent,
        contentProps: slotProps == null ? void 0 : slotProps.itemContent,
        sx: {
          mx: 2
        },
        classes
      }) : (0, import_jsx_runtime15.jsx)(ChartsAxisTooltipContent, {
        axisData: displayedData,
        content: (slots == null ? void 0 : slots.axisContent) ?? axisContent,
        contentProps: slotProps == null ? void 0 : slotProps.axisContent,
        sx: {
          mx: 2
        },
        classes
      })
    }))
  });
}
true ? ChartsTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Component to override the tooltip content when trigger is set to 'axis'.
   * @deprecated Use slots.axisContent instead
   */
  axisContent: import_prop_types8.default.elementType,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types8.default.object,
  /**
   * Component to override the tooltip content when trigger is set to 'item'.
   * @deprecated Use slots.itemContent instead
   */
  itemContent: import_prop_types8.default.elementType,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types8.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types8.default.object,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'axis'
   */
  trigger: import_prop_types8.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/useItemTooltip.js
var React35 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsTooltip/useAxisTooltip.js
var React36 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsClipPath/ChartsClipPath.js
var React37 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
function ChartsClipPath(props) {
  const {
    id,
    offset: offsetProps
  } = props;
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const offset = _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, offsetProps);
  return (0, import_jsx_runtime16.jsx)("clipPath", {
    id,
    children: (0, import_jsx_runtime16.jsx)("rect", {
      x: left - offset.left,
      y: top - offset.top,
      width: width + offset.left + offset.right,
      height: height + offset.top + offset.bottom
    })
  });
}
true ? ChartsClipPath.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  id: import_prop_types9.default.string.isRequired,
  offset: import_prop_types9.default.shape({
    bottom: import_prop_types9.default.number,
    left: import_prop_types9.default.number,
    right: import_prop_types9.default.number,
    top: import_prop_types9.default.number
  })
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsOnAxisClickHandler/ChartsOnAxisClickHandler.js
var React38 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
function ChartsOnAxisClickHandler(props) {
  const {
    onAxisClick
  } = props;
  const svgRef = useSvgRef();
  const series = useSeries();
  const {
    axis
  } = React38.useContext(InteractionContext);
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  React38.useEffect(() => {
    const element = svgRef.current;
    if (element === null || !onAxisClick) {
      return () => {
      };
    }
    const handleMouseClick = (event) => {
      var _a;
      event.preventDefault();
      const isXaxis = axis.x && axis.x.index !== -1;
      const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
      const dataIndex = isXaxis ? axis.x && axis.x.index : axis.y && axis.y.index;
      if (dataIndex == null) {
        return;
      }
      const seriesValues = {};
      Object.keys(series).filter((seriesType) => ["bar", "line"].includes(seriesType)).forEach((seriesType) => {
        var _a2;
        (_a2 = series[seriesType]) == null ? void 0 : _a2.seriesOrder.forEach((seriesId) => {
          const seriesItem = series[seriesType].series[seriesId];
          const providedXAxisId = seriesItem.xAxisId ?? seriesItem.xAxisKey;
          const providedYAxisId = seriesItem.yAxisId ?? seriesItem.yAxisKey;
          const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
          if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
            seriesValues[seriesId] = seriesItem.data[dataIndex];
          }
        });
      });
      const axisValue = (_a = (isXaxis ? xAxis : yAxis)[USED_AXIS_ID].data) == null ? void 0 : _a[dataIndex];
      onAxisClick(event, {
        dataIndex,
        axisValue,
        seriesValues
      });
    };
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("click", handleMouseClick);
    };
  }, [axis.x, axis.y, onAxisClick, series, svgRef, xAxis, xAxisIds, yAxis, yAxisIds]);
  return (0, import_jsx_runtime17.jsx)(React38.Fragment, {});
}
true ? ChartsOnAxisClickHandler.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types10.default.func
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsOverlay/ChartsOverlay.js
var React41 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsOverlay/ChartsLoadingOverlay.js
var React39 = __toESM(require_react());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var _excluded5 = ["message"];
var StyledText = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsLoadingOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime18.jsx)(StyledText, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "Loading data…"
  }));
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsOverlay/ChartsNoDataOverlay.js
var React40 = __toESM(require_react());
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var _excluded6 = ["message"];
var StyledText2 = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsNoDataOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime19.jsx)(StyledText2, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "No data to display"
  }));
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsOverlay/ChartsOverlay.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
function useNoData() {
  const seriesPerType = useSeries();
  return Object.values(seriesPerType).every((seriesOfGivenType) => {
    if (!seriesOfGivenType) {
      return true;
    }
    const {
      series,
      seriesOrder
    } = seriesOfGivenType;
    return seriesOrder.every((seriesId) => series[seriesId].data.length === 0);
  });
}
function ChartsOverlay(props) {
  var _a, _b, _c, _d;
  const noData = useNoData();
  if (props.loading) {
    const LoadingOverlay = ((_a = props.slots) == null ? void 0 : _a.loadingOverlay) ?? ChartsLoadingOverlay;
    return (0, import_jsx_runtime20.jsx)(LoadingOverlay, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.loadingOverlay));
  }
  if (noData) {
    const NoDataOverlay = ((_c = props.slots) == null ? void 0 : _c.noDataOverlay) ?? ChartsNoDataOverlay;
    return (0, import_jsx_runtime20.jsx)(NoDataOverlay, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.noDataOverlay));
  }
  return null;
}

// node_modules/@mui/x-charts-pro/ResponsiveChartContainerPro/ResponsiveChartContainerPro.js
var React65 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());

// node_modules/@mui/x-license/Watermark/Watermark.js
var React44 = __toESM(require_react());

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
var React43 = __toESM(require_react());

// node_modules/@mui/x-license/encoding/base64.js
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64Decode = (input) => {
  let output = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i2 = 0;
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  while (i2 < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i2++));
    enc2 = _keyStr.indexOf(input.charAt(i2++));
    enc3 = _keyStr.indexOf(input.charAt(i2++));
    enc4 = _keyStr.indexOf(input.charAt(i2++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output = output + String.fromCharCode(chr1);
    if (enc3 != 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 != 64) {
      output = output + String.fromCharCode(chr3);
    }
  }
  return output;
};

// node_modules/@mui/x-license/encoding/md5.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
function md5(s) {
  const words = [];
  let b, c, d, j = unescape(encodeURI(s)) + "", a = j.length;
  const h = [b = 1732584193, c = 4023233417, ~b, ~c];
  s = --a / 4 + 2 | 15;
  words[--s] = a * 8;
  for (; ~a; ) {
    words[a >> 2] |= j.charCodeAt(a) << 8 * a--;
  }
  for (i = j = 0; i < s; i += 16) {
    a = h;
    for (; j < 64; a = [d = a[3], b + ((d = a[0] + [b & c | ~b & d, d & b | ~d & c, b ^ c ^ d, c ^ (b | ~d)][a = j >> 4] + k[j] + ~~words[i | [j, 5 * j + 1, 3 * j + 5, 7 * j][a] & 15]) << (a = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * a + j++ % 4]) | d >>> -a), b, c]) {
      b = a[1] | 0;
      c = a[2];
    }
    for (j = 4; j; )
      h[--j] += a[j];
  }
  for (s = ""; j < 32; ) {
    s += (h[j >> 3] >> (1 ^ j++) * 4 & 15).toString(16);
  }
  return s;
}

// node_modules/@mui/x-license/utils/licenseStatus.js
var LICENSE_STATUS = function(LICENSE_STATUS2) {
  LICENSE_STATUS2["NotFound"] = "NotFound";
  LICENSE_STATUS2["Invalid"] = "Invalid";
  LICENSE_STATUS2["ExpiredAnnual"] = "ExpiredAnnual";
  LICENSE_STATUS2["ExpiredAnnualGrace"] = "ExpiredAnnualGrace";
  LICENSE_STATUS2["ExpiredVersion"] = "ExpiredVersion";
  LICENSE_STATUS2["Valid"] = "Valid";
  LICENSE_STATUS2["OutOfScope"] = "OutOfScope";
  LICENSE_STATUS2["NotAvailableInInitialProPlan"] = "NotAvailableInInitialProPlan";
  return LICENSE_STATUS2;
}({});

// node_modules/@mui/x-license/utils/plan.js
var PLAN_SCOPES = ["pro", "premium"];

// node_modules/@mui/x-license/utils/licenseModel.js
var LICENSE_MODELS = [
  /**
   * A license is outdated if the current version of the software was released after the expiry date of the license.
   * But the license can be used indefinitely with an older version of the software.
   */
  "perpetual",
  /**
   * On development, a license is outdated if the expiry date has been reached
   * On production, a license is outdated if the current version of the software was released after the expiry date of the license (see "perpetual")
   */
  "annual",
  /**
   * Legacy. The previous name for 'annual'.
   * Can be removed once old license keys generated with 'subscription' are no longer supported.
   * To support for a while. We need more years of backward support and we sell multi year licenses.
   */
  "subscription"
];

// node_modules/@mui/x-license/verifyLicense/verifyLicense.js
function isPlanScopeSufficient(packageName, planScope) {
  let acceptedScopes;
  if (packageName.includes("-pro")) {
    acceptedScopes = ["pro", "premium"];
  } else if (packageName.includes("-premium")) {
    acceptedScopes = ["premium"];
  } else {
    acceptedScopes = [];
  }
  return acceptedScopes.includes(planScope);
}
var expiryReg = /^.*EXPIRY=([0-9]+),.*$/;
var PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN = ["x-data-grid-pro", "x-date-pickers-pro"];
var decodeLicenseVersion1 = (license) => {
  let expiryTimestamp;
  try {
    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);
    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {
      expiryTimestamp = null;
    }
  } catch (err) {
    expiryTimestamp = null;
  }
  return {
    planScope: "pro",
    licenseModel: "perpetual",
    expiryTimestamp,
    planVersion: "initial"
  };
};
var decodeLicenseVersion2 = (license) => {
  const licenseInfo = {
    planScope: null,
    licenseModel: null,
    expiryTimestamp: null,
    planVersion: "initial"
  };
  license.split(",").map((token) => token.split("=")).filter((el) => el.length === 2).forEach(([key, value]) => {
    if (key === "S") {
      licenseInfo.planScope = value;
    }
    if (key === "LM") {
      licenseInfo.licenseModel = value;
    }
    if (key === "E") {
      const expiryTimestamp = parseInt(value, 10);
      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {
        licenseInfo.expiryTimestamp = expiryTimestamp;
      }
    }
    if (key === "PV") {
      licenseInfo.planVersion = value;
    }
  });
  return licenseInfo;
};
var decodeLicense = (encodedLicense) => {
  const license = base64Decode(encodedLicense);
  if (license.includes("KEYVERSION=1")) {
    return decodeLicenseVersion1(license);
  }
  if (license.includes("KV=2")) {
    return decodeLicenseVersion2(license);
  }
  return null;
};
function verifyLicense({
  releaseInfo: releaseInfo3,
  licenseKey,
  packageName
}) {
  if (!releaseInfo3) {
    throw new Error("MUI X: The release information is missing. Not able to validate license.");
  }
  if (!licenseKey) {
    return {
      status: LICENSE_STATUS.NotFound
    };
  }
  const hash = licenseKey.substr(0, 32);
  const encoded = licenseKey.substr(32);
  if (hash !== md5(encoded)) {
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  const license = decodeLicense(encoded);
  if (license == null) {
    console.error("MUI X: Error checking license. Key version not found!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licenseModel == null || !LICENSE_MODELS.includes(license.licenseModel)) {
    console.error("MUI X: Error checking license. Licensing model not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.expiryTimestamp == null) {
    console.error("MUI X: Error checking license. Expiry timestamp not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licenseModel === "perpetual" || false) {
    const pkgTimestamp = parseInt(base64Decode(releaseInfo3), 10);
    if (Number.isNaN(pkgTimestamp)) {
      throw new Error("MUI X: The release information is invalid. Not able to validate license.");
    }
    if (license.expiryTimestamp < pkgTimestamp) {
      return {
        status: LICENSE_STATUS.ExpiredVersion
      };
    }
  } else if (license.licenseModel === "subscription" || license.licenseModel === "annual") {
    if ((/* @__PURE__ */ new Date()).getTime() > license.expiryTimestamp) {
      if (
        // 30 days grace
        (/* @__PURE__ */ new Date()).getTime() < license.expiryTimestamp + 1e3 * 3600 * 24 * 30 || false
      ) {
        return {
          status: LICENSE_STATUS.ExpiredAnnualGrace,
          meta: {
            expiryTimestamp: license.expiryTimestamp,
            licenseKey
          }
        };
      }
      return {
        status: LICENSE_STATUS.ExpiredAnnual,
        meta: {
          expiryTimestamp: license.expiryTimestamp,
          licenseKey
        }
      };
    }
  }
  if (license.planScope == null || !PLAN_SCOPES.includes(license.planScope)) {
    console.error("MUI X: Error checking license. planScope not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (!isPlanScopeSufficient(packageName, license.planScope)) {
    return {
      status: LICENSE_STATUS.OutOfScope
    };
  }
  if (license.planVersion === "initial" && license.planScope === "pro" && !PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN.includes(packageName)) {
    return {
      status: LICENSE_STATUS.NotAvailableInInitialProPlan
    };
  }
  return {
    status: LICENSE_STATUS.Valid
  };
}

// node_modules/@mui/x-license/utils/licenseInfo.js
ponyfillGlobal_default.__MUI_LICENSE_INFO__ = ponyfillGlobal_default.__MUI_LICENSE_INFO__ || {
  key: void 0
};
var LicenseInfo = class _LicenseInfo {
  static getLicenseInfo() {
    return ponyfillGlobal_default.__MUI_LICENSE_INFO__;
  }
  static getLicenseKey() {
    return _LicenseInfo.getLicenseInfo().key;
  }
  static setLicenseKey(key) {
    const licenseInfo = _LicenseInfo.getLicenseInfo();
    licenseInfo.key = key;
  }
};

// node_modules/@mui/x-license/utils/licenseErrorMessageUtils.js
function showError(message) {
  console.error(["*************************************************************", "", ...message, "", "*************************************************************"].join("\n"));
}
function showInvalidLicenseKeyError() {
  showError(["MUI X: Invalid license key.", "", "Your MUI X license key format isn't valid. It could be because the license key is missing a character or has a typo.", "", "To solve the issue, you need to double check that `setLicenseKey()` is called with the right argument", "Please check the license key installation https://mui.com/r/x-license-key-installation."]);
}
function showLicenseKeyPlanMismatchError() {
  showError(["MUI X: License key plan mismatch.", "", "Your use of MUI X is not compatible with the plan of your license key. The feature you are trying to use is not included in the plan of your license key. This happens if you try to use Data Grid Premium with a license key for the Pro plan.", "", "To solve the issue, you can upgrade your plan from Pro to Premium at https://mui.com/r/x-get-license?scope=premium.", "Of if you didn't intend to use Premium features, you can replace the import of `@mui/x-data-grid-premium` with `@mui/x-data-grid-pro`."]);
}
function showNotAvailableInInitialProPlanError() {
  showError(["MUI X: Component not included in your license.", "", "The component you are trying to use is not included in the Pro Plan you purchased.", "", "Your license is from an old version of the Pro Plan that is only compatible with the `@mui/x-data-grid-pro` and `@mui/x-date-pickers-pro` commercial packages.", "", "To start using another Pro package, please consider reaching to our sales team to upgrade your license or visit https://mui.com/r/x-get-license to get a new license key."]);
}
function showMissingLicenseKeyError({
  plan,
  packageName
}) {
  showError(["MUI X: Missing license key.", "", `The license key is missing. You might not be allowed to use \`${packageName}\` which is part of MUI X ${plan}.`, "", "To solve the issue, you can check the free trial conditions: https://mui.com/r/x-license-trial.", "If you are eligible no actions are required. If you are not eligible to the free trial, you need to purchase a license https://mui.com/r/x-get-license or stop using the software immediately."]);
}
function showExpiredPackageVersionError({
  packageName
}) {
  showError(["MUI X: Expired package version.", "", `You have installed a version of \`${packageName}\` that is outside of the maintenance plan of your license key. By default, commercial licenses provide access to new versions released during the first year after the purchase.`, "", "To solve the issue, you can renew your license https://mui.com/r/x-get-license or install an older version of the npm package that is compatible with your license key."]);
}
function showExpiredAnnualGraceLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  showError(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""]);
}
function showExpiredAnnualLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  throw new Error(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""].join("\n"));
}

// node_modules/@mui/x-license/Unstable_LicenseInfoProvider/MuiLicenseInfoContext.js
var React42 = __toESM(require_react());
var MuiLicenseInfoContext = React42.createContext({
  key: void 0
});
if (true) {
  MuiLicenseInfoContext.displayName = "MuiLicenseInfoContext";
}
var MuiLicenseInfoContext_default = MuiLicenseInfoContext;

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
var sharedLicenseStatuses = {};
function useLicenseVerifier(packageName, releaseInfo3) {
  const {
    key: contextKey
  } = React43.useContext(MuiLicenseInfoContext_default);
  return React43.useMemo(() => {
    const licenseKey = contextKey ?? LicenseInfo.getLicenseKey();
    if (sharedLicenseStatuses[packageName] && sharedLicenseStatuses[packageName].key === licenseKey) {
      return sharedLicenseStatuses[packageName].licenseVerifier;
    }
    const plan = packageName.includes("premium") ? "Premium" : "Pro";
    const licenseStatus = verifyLicense({
      releaseInfo: releaseInfo3,
      licenseKey,
      packageName
    });
    const fullPackageName = `@mui/${packageName}`;
    if (licenseStatus.status === LICENSE_STATUS.Valid) {
    } else if (licenseStatus.status === LICENSE_STATUS.Invalid) {
      showInvalidLicenseKeyError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotAvailableInInitialProPlan) {
      showNotAvailableInInitialProPlanError();
    } else if (licenseStatus.status === LICENSE_STATUS.OutOfScope) {
      showLicenseKeyPlanMismatchError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotFound) {
      showMissingLicenseKeyError({
        plan,
        packageName: fullPackageName
      });
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnualGrace) {
      showExpiredAnnualGraceLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnual) {
      showExpiredAnnualLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredVersion) {
      showExpiredPackageVersionError({
        packageName: fullPackageName
      });
    } else if (true) {
      throw new Error("missing status handler");
    }
    sharedLicenseStatuses[packageName] = {
      key: licenseKey,
      licenseVerifier: licenseStatus
    };
    return licenseStatus;
  }, [packageName, releaseInfo3, contextKey]);
}

// node_modules/@mui/x-license/Watermark/Watermark.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
function getLicenseErrorMessage(licenseStatus) {
  switch (licenseStatus) {
    case LICENSE_STATUS.ExpiredAnnualGrace:
    case LICENSE_STATUS.ExpiredAnnual:
      return "MUI X Expired license key";
    case LICENSE_STATUS.ExpiredVersion:
      return "MUI X Expired package version";
    case LICENSE_STATUS.Invalid:
      return "MUI X Invalid license key";
    case LICENSE_STATUS.OutOfScope:
      return "MUI X License key plan mismatch";
    case LICENSE_STATUS.NotAvailableInInitialProPlan:
      return "MUI X Product not covered by plan";
    case LICENSE_STATUS.NotFound:
      return "MUI X Missing license key";
    default:
      throw new Error("Unhandled MUI X license status.");
  }
}
function Watermark(props) {
  const {
    packageName,
    releaseInfo: releaseInfo3
  } = props;
  const licenseStatus = useLicenseVerifier(packageName, releaseInfo3);
  if (licenseStatus.status === LICENSE_STATUS.Valid) {
    return null;
  }
  return (0, import_jsx_runtime21.jsx)("div", {
    style: {
      position: "absolute",
      pointerEvents: "none",
      color: "#8282829e",
      zIndex: 1e5,
      width: "100%",
      textAlign: "center",
      bottom: "50%",
      right: 0,
      letterSpacing: 5,
      fontSize: 24
    },
    children: getLicenseErrorMessage(licenseStatus.status)
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
var React47 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsPiecewiseGradient.js
var React45 = __toESM(require_react());
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
function ChartsPiecewiseGradient(props) {
  const {
    isReversed,
    gradientId,
    size,
    direction,
    scale,
    colorMap
  } = props;
  return (0, import_jsx_runtime22.jsx)("linearGradient", {
    id: gradientId,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${direction}${isReversed ? 1 : 2}`]: `${size}px`,
    gradientUnits: "userSpaceOnUse",
    children: colorMap.thresholds.map((threshold2, index) => {
      const x = scale(threshold2);
      if (x === void 0) {
        return null;
      }
      const offset = isReversed ? 1 - x / size : x / size;
      return (0, import_jsx_runtime22.jsxs)(React45.Fragment, {
        children: [(0, import_jsx_runtime22.jsx)("stop", {
          offset,
          stopColor: colorMap.colors[index],
          stopOpacity: 1
        }), (0, import_jsx_runtime22.jsx)("stop", {
          offset,
          stopColor: colorMap.colors[index + 1],
          stopOpacity: 1
        })]
      }, threshold2.toString() + index);
    })
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsContinuousGradient.js
var React46 = __toESM(require_react());
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var PX_PRECISION = 10;
function ChartsContinuousGradient(props) {
  const {
    gradientUnits,
    isReversed,
    gradientId,
    size,
    direction,
    scale,
    colorScale,
    colorMap
  } = props;
  const extremValues = [colorMap.min ?? 0, colorMap.max ?? 100];
  const extremPositions = extremValues.map(scale).filter((p) => p !== void 0);
  if (extremPositions.length !== 2) {
    return null;
  }
  const interpolator = typeof extremValues[0] === "number" ? number_default(extremValues[0], extremValues[1]) : date_default(extremValues[0], extremValues[1]);
  const numberOfPoints = Math.round((Math.max(...extremPositions) - Math.min(...extremPositions)) / PX_PRECISION);
  const keyPrefix = `${extremValues[0]}-${extremValues[1]}-`;
  return (0, import_jsx_runtime23.jsx)("linearGradient", {
    id: gradientId,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${direction}${isReversed ? 1 : 2}`]: gradientUnits === "objectBoundingBox" ? 1 : `${size}px`,
    gradientUnits: gradientUnits ?? "userSpaceOnUse",
    children: Array.from({
      length: numberOfPoints + 1
    }, (_, index) => {
      const value = interpolator(index / numberOfPoints);
      if (value === void 0) {
        return null;
      }
      const x = scale(value);
      if (x === void 0) {
        return null;
      }
      const offset = isReversed ? 1 - x / size : x / size;
      const color = colorScale(value);
      if (color === null) {
        return null;
      }
      return (0, import_jsx_runtime23.jsx)("stop", {
        offset,
        stopColor: color,
        stopOpacity: 1
      }, keyPrefix + index);
    })
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
function useChartGradient() {
  const {
    chartId
  } = React47.useContext(DrawingContext);
  return React47.useCallback((axisId, direction) => `${chartId}-gradient-${direction}-${axisId}`, [chartId]);
}
function ChartsAxesGradients() {
  const {
    top,
    height,
    bottom,
    left,
    width,
    right
  } = useDrawingArea();
  const svgHeight = top + height + bottom;
  const svgWidth = left + width + right;
  const getGradientId = useChartGradient();
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  return (0, import_jsx_runtime24.jsxs)("defs", {
    children: [yAxisIds.filter((axisId) => yAxis[axisId].colorMap !== void 0).map((axisId) => {
      const gradientId = getGradientId(axisId, "y");
      const {
        colorMap,
        scale,
        colorScale,
        reverse
      } = yAxis[axisId];
      if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
        return (0, import_jsx_runtime24.jsx)(ChartsPiecewiseGradient, {
          isReversed: !reverse,
          scale,
          colorMap,
          size: svgHeight,
          gradientId,
          direction: "y"
        }, gradientId);
      }
      if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
        return (0, import_jsx_runtime24.jsx)(ChartsContinuousGradient, {
          isReversed: !reverse,
          scale,
          colorScale,
          colorMap,
          size: svgHeight,
          gradientId,
          direction: "y"
        }, gradientId);
      }
      return null;
    }), xAxisIds.filter((axisId) => xAxis[axisId].colorMap !== void 0).map((axisId) => {
      const gradientId = getGradientId(axisId, "x");
      const {
        colorMap,
        scale,
        reverse,
        colorScale
      } = xAxis[axisId];
      if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
        return (0, import_jsx_runtime24.jsx)(ChartsPiecewiseGradient, {
          isReversed: reverse,
          scale,
          colorMap,
          size: svgWidth,
          gradientId,
          direction: "x"
        }, gradientId);
      }
      if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
        return (0, import_jsx_runtime24.jsx)(ChartsContinuousGradient, {
          isReversed: reverse,
          scale,
          colorScale,
          colorMap,
          size: svgWidth,
          gradientId,
          direction: "x"
        }, gradientId);
      }
      return null;
    })]
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ResponsiveChartContainer/useChartContainerDimensions.js
var React48 = __toESM(require_react());
var useChartContainerDimensions = (inWidth, inHeight, resolveSizeBeforeRender) => {
  const stateRef = React48.useRef({
    displayError: false,
    initialCompute: true,
    computeRun: 0
  });
  const rootRef = React48.useRef(null);
  const [width, setWidth] = React48.useState(0);
  const [height, setHeight] = React48.useState(0);
  const computeSize = React48.useCallback(() => {
    const mainEl = rootRef == null ? void 0 : rootRef.current;
    if (!mainEl) {
      return {};
    }
    const win = ownerWindow(mainEl);
    const computedStyle = win.getComputedStyle(mainEl);
    const newHeight = Math.floor(parseFloat(computedStyle.height)) || 0;
    const newWidth = Math.floor(parseFloat(computedStyle.width)) || 0;
    setWidth(newWidth);
    setHeight(newHeight);
    return {
      width: newWidth,
      height: newHeight
    };
  }, []);
  React48.useEffect(() => {
    stateRef.current.displayError = true;
  }, []);
  useEnhancedEffect_default(() => {
    if (!resolveSizeBeforeRender || !stateRef.current.initialCompute || stateRef.current.computeRun > 20) {
      return;
    }
    const computedSize = computeSize();
    if (computedSize.width !== width || computedSize.height !== height) {
      stateRef.current.computeRun += 1;
    } else if (stateRef.current.initialCompute) {
      stateRef.current.initialCompute = false;
    }
  }, [width, height, computeSize, resolveSizeBeforeRender]);
  useEnhancedEffect_default(() => {
    if (inWidth !== void 0 && inHeight !== void 0) {
      return () => {
      };
    }
    computeSize();
    const elementToObserve = rootRef.current;
    if (typeof ResizeObserver === "undefined") {
      return () => {
      };
    }
    let animationFrame;
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        computeSize();
      });
    });
    if (elementToObserve) {
      observer.observe(elementToObserve);
    }
    return () => {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
      if (elementToObserve) {
        observer.unobserve(elementToObserve);
      }
    };
  }, [computeSize, inHeight, inWidth]);
  if (true) {
    if (stateRef.current.displayError && inWidth === void 0 && width === 0) {
      console.error(`MUI X: ChartContainer does not have \`width\` prop, and its container has no \`width\` defined.`);
      stateRef.current.displayError = false;
    }
    if (stateRef.current.displayError && inHeight === void 0 && height === 0) {
      console.error(`MUI X: ChartContainer does not have \`height\` prop, and its container has no \`height\` defined.`);
      stateRef.current.displayError = false;
    }
  }
  return {
    containerRef: rootRef,
    width: inWidth ?? width,
    height: inHeight ?? height
  };
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ResponsiveChartContainer/ResizableContainer.js
var ResizableContainer = styled_default("div", {
  name: "MuiResponsiveChart",
  slot: "Container"
})(({
  ownerState
}) => ({
  width: ownerState.width ?? "100%",
  height: ownerState.height ?? "100%",
  display: "flex",
  position: "relative",
  flexGrow: 1,
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  "&>svg": {
    width: "100%",
    height: "100%"
  }
}));

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useInteractionItemProps.js
var React52 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/HighlightedProvider/HighlightedProvider.js
var React50 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/HighlightedProvider/HighlightedContext.js
var React49 = __toESM(require_react());
var HighlightedContext = React49.createContext({
  isInitialized: false,
  data: {
    highlightedItem: null,
    setHighlighted: () => {
    },
    clearHighlighted: () => {
    },
    isHighlighted: () => false,
    isFaded: () => false
  }
});
if (true) {
  HighlightedContext.displayName = "HighlightedContext";
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/HighlightedProvider/createIsFaded.js
var createIsFaded = (highlightScope, highlightedItem) => (input) => {
  if (!highlightScope) {
    return false;
  }
  if (highlightScope.fade === "series") {
    return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId) && input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
  }
  if (highlightScope.fade === "global") {
    return input.seriesId !== (highlightedItem == null ? void 0 : highlightedItem.seriesId) || input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
  }
  return false;
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/HighlightedProvider/createIsHighlighted.js
var createIsHighlighted = (highlightScope, highlightedItem) => (input) => {
  if (!highlightScope) {
    return false;
  }
  if (highlightScope.highlight === "series") {
    return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
  }
  if (highlightScope.highlight === "item") {
    return input.dataIndex === (highlightedItem == null ? void 0 : highlightedItem.dataIndex) && input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
  }
  return false;
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/HighlightedProvider/HighlightedProvider.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var _excluded7 = ["highlighted", "faded"];
var mergeDeprecatedOptions = (options) => {
  const _ref = options ?? {}, {
    highlighted,
    faded
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded7);
  return _extends({
    highlight: highlighted,
    fade: faded
  }, other);
};
function HighlightedProvider({
  children,
  highlightedItem: highlightedItemProps,
  onHighlightChange
}) {
  const [highlightedItem, setHighlightedItem] = useControlled({
    controlled: highlightedItemProps,
    default: null,
    name: "HighlightedProvider",
    state: "highlightedItem"
  });
  const series = useSeries();
  const seriesById = React50.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    Object.keys(series).forEach((seriesType) => {
      const seriesData = series[seriesType];
      Object.keys((seriesData == null ? void 0 : seriesData.series) ?? {}).forEach((seriesId) => {
        const seriesItem = seriesData == null ? void 0 : seriesData.series[seriesId];
        map.set(seriesId, mergeDeprecatedOptions(seriesItem == null ? void 0 : seriesItem.highlightScope));
      });
    });
    return map;
  }, [series]);
  const highlightScope = highlightedItem && highlightedItem.seriesId ? seriesById.get(highlightedItem.seriesId) ?? void 0 : void 0;
  const providerValue = React50.useMemo(() => {
    return {
      isInitialized: true,
      data: {
        highlightScope,
        highlightedItem,
        setHighlighted: (itemData) => {
          setHighlightedItem(itemData);
          onHighlightChange == null ? void 0 : onHighlightChange(itemData);
        },
        clearHighlighted: () => {
          setHighlightedItem(null);
          onHighlightChange == null ? void 0 : onHighlightChange(null);
        },
        isHighlighted: createIsHighlighted(highlightScope, highlightedItem),
        isFaded: createIsFaded(highlightScope, highlightedItem)
      }
    };
  }, [highlightedItem, highlightScope, setHighlightedItem, onHighlightChange]);
  return (0, import_jsx_runtime25.jsx)(HighlightedContext.Provider, {
    value: providerValue,
    children
  });
}
true ? HighlightedProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types11.default.node,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types11.default.shape({
    dataIndex: import_prop_types11.default.number,
    seriesId: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string])
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types11.default.func
} : void 0;

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/HighlightedProvider/useHighlighted.js
var React51 = __toESM(require_react());
function useHighlighted() {
  const {
    isInitialized,
    data
  } = React51.useContext(HighlightedContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the highlighted ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/HighlightedProvider/useItemHighlighted.js
function useItemHighlighted(item) {
  const highlighted = useHighlighted();
  if (!item) {
    return {
      isHighlighted: false,
      isFaded: false
    };
  }
  const isHighlighted = highlighted.isHighlighted(item);
  const isFaded = !isHighlighted && highlighted.isFaded(item);
  return {
    isHighlighted,
    isFaded
  };
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useInteractionItemProps.js
var useInteractionItemProps = (skip) => {
  const {
    dispatch: dispatchInteraction
  } = React52.useContext(InteractionContext);
  const {
    setHighlighted,
    clearHighlighted
  } = useHighlighted();
  if (skip) {
    return () => ({});
  }
  const getInteractionItemProps = (data) => {
    const onPointerDown = (event) => {
      if (event.currentTarget.hasPointerCapture(event.pointerId)) {
        event.currentTarget.releasePointerCapture(event.pointerId);
      }
    };
    const onPointerEnter = () => {
      dispatchInteraction({
        type: "enterItem",
        data
      });
      setHighlighted({
        seriesId: data.seriesId,
        dataIndex: data.dataIndex
      });
    };
    const onPointerLeave = (event) => {
      event.currentTarget.releasePointerCapture(event.pointerId);
      dispatchInteraction({
        type: "leaveItem",
        data
      });
      clearHighlighted();
    };
    return {
      onPointerEnter,
      onPointerLeave,
      onPointerDown
    };
  };
  return getInteractionItemProps;
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ResponsiveChartContainer/useResponsiveChartContainerProps.js
var _excluded8 = ["width", "height", "resolveSizeBeforeRender", "margin", "children", "series", "colors", "dataset", "desc", "disableAxisListener", "highlightedItem", "onHighlightChange", "plugins", "sx", "title", "viewBox", "xAxis", "yAxis", "zAxis", "skipAnimation"];
var useResponsiveChartContainerProps = (props, ref) => {
  const {
    width,
    height,
    resolveSizeBeforeRender,
    margin,
    children,
    series,
    colors,
    dataset,
    desc,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    plugins,
    sx,
    title,
    viewBox,
    xAxis,
    yAxis,
    zAxis,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  const {
    containerRef,
    width: dWidth,
    height: dHeight
  } = useChartContainerDimensions(width, height, resolveSizeBeforeRender);
  const resizableChartContainerProps = _extends({}, other, {
    ownerState: {
      width,
      height
    },
    ref: containerRef
  });
  const chartContainerProps = {
    margin,
    children,
    series,
    colors,
    dataset,
    desc,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    plugins,
    sx,
    title,
    viewBox,
    xAxis,
    yAxis,
    zAxis,
    skipAnimation,
    width: dWidth,
    height: dHeight,
    ref
  };
  return {
    hasIntrinsicSize: dWidth && dHeight,
    chartContainerProps,
    resizableChartContainerProps
  };
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartContainer/useChartContainerProps.js
var React54 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartContainer/useDefaultizeAxis.js
var React53 = __toESM(require_react());
var defaultizeAxis = (inAxis, dataset, axisName) => {
  const DEFAULT_AXIS_KEY = axisName === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
  return [...(inAxis == null ? void 0 : inAxis.map((axis, index) => _extends({
    id: `defaultized-${axisName}-axis-${index}`
  }, axis))) ?? [], ...inAxis === void 0 || inAxis.findIndex(({
    id
  }) => id === DEFAULT_AXIS_KEY) === -1 ? [{
    id: DEFAULT_AXIS_KEY,
    scaleType: "linear"
  }] : []].map((axisConfig) => {
    const dataKey = axisConfig.dataKey;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return axisConfig;
    }
    if (dataset === void 0) {
      throw new Error(`MUI X: ${axisName}-axis uses \`dataKey\` but no \`dataset\` is provided.`);
    }
    return _extends({}, axisConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  });
};
var useDefaultizeAxis = (inXAxis, inYAxis, dataset) => {
  const xAxis = React53.useMemo(() => defaultizeAxis(inXAxis, dataset, "x"), [inXAxis, dataset]);
  const yAxis = React53.useMemo(() => defaultizeAxis(inYAxis, dataset, "y"), [inYAxis, dataset]);
  return [xAxis, yAxis];
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartContainer/useChartContainerProps.js
var _excluded9 = ["width", "height", "series", "margin", "xAxis", "yAxis", "zAxis", "colors", "dataset", "sx", "title", "desc", "disableAxisListener", "highlightedItem", "onHighlightChange", "plugins", "children", "skipAnimation"];
var useChartContainerProps = (props, ref) => {
  const {
    width,
    height,
    series,
    margin,
    xAxis,
    yAxis,
    zAxis,
    colors,
    dataset,
    sx,
    title,
    desc,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    plugins,
    children,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const svgRef = React54.useRef(null);
  const chartSurfaceRef = useForkRef(ref, svgRef);
  const [defaultizedXAxis, defaultizedYAxis] = useDefaultizeAxis(xAxis, yAxis, dataset);
  const drawingProviderProps = {
    width,
    height,
    margin,
    svgRef
  };
  const animationProviderProps = {
    skipAnimation
  };
  const pluginProviderProps = {
    plugins
  };
  const seriesProviderProps = {
    series,
    colors,
    dataset
  };
  const cartesianProviderProps = {
    xAxis: defaultizedXAxis,
    yAxis: defaultizedYAxis,
    dataset
  };
  const zAxisContextProps = {
    zAxis,
    dataset
  };
  const highlightedProviderProps = {
    highlightedItem,
    onHighlightChange
  };
  const chartsSurfaceProps = _extends({}, other, {
    width,
    height,
    ref: chartSurfaceRef,
    sx,
    title,
    desc,
    disableAxisListener
  });
  return {
    children,
    drawingProviderProps,
    seriesProviderProps,
    cartesianProviderProps,
    zAxisContextProps,
    highlightedProviderProps,
    chartsSurfaceProps,
    pluginProviderProps,
    animationProviderProps,
    xAxis: defaultizedXAxis,
    yAxis: defaultizedYAxis
  };
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/getSVGPoint.js
function getSVGPoint(svg, event) {
  const pt = svg.createSVGPoint();
  pt.x = event.clientX;
  pt.y = event.clientY;
  return pt.matrixTransform(svg.getScreenCTM().inverse());
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/internals/isDefined.js
function isDefined(value) {
  return value !== null && value !== void 0;
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/AnimationProvider/AnimationContext.js
var React55 = __toESM(require_react());
var AnimationContext = React55.createContext({
  isInitialized: false,
  data: {
    skipAnimation: void 0
  }
});
if (true) {
  AnimationContext.displayName = "AnimationContext";
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/AnimationProvider/AnimationProvider.js
var React56 = __toESM(require_react());
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
function AnimationProvider(props) {
  const {
    children,
    skipAnimation: inSkipAnimation
  } = props;
  const isAnimationDisabledEnvironment = typeof window === "undefined" || !(window == null ? void 0 : window.matchMedia);
  const [skipAnimation, setSkipAnimation] = React56.useState(isAnimationDisabledEnvironment || void 0);
  useIsomorphicLayoutEffect(() => {
    var _a;
    if (isAnimationDisabledEnvironment) {
      return void 0;
    }
    const handleMediaChange = (event) => {
      const inputValue = event.matches || void 0;
      setSkipAnimation(inputValue);
      globals_exports.assign({
        skipAnimation: inputValue
      });
    };
    const mql = window.matchMedia("(prefers-reduced-motion)");
    handleMediaChange(mql);
    (_a = mql == null ? void 0 : mql.addEventListener) == null ? void 0 : _a.call(mql, "change", handleMediaChange);
    return () => {
      var _a2;
      (_a2 = mql == null ? void 0 : mql.removeEventListener) == null ? void 0 : _a2.call(mql, "change", handleMediaChange);
    };
  }, []);
  const value = React56.useMemo(() => ({
    isInitialized: true,
    data: {
      // If dev sets `skipAnimation` to true, it will skip all animations.
      // If dev sets `skipAnimation` to false, it will use user's preference.
      skipAnimation: inSkipAnimation || skipAnimation
    }
  }), [skipAnimation, inSkipAnimation]);
  return (0, import_jsx_runtime26.jsx)(AnimationContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/context/AnimationProvider/useSkipAnimation.js
var React57 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/internals/utils/releaseInfo.js
var getReleaseInfo = () => {
  const releaseInfo3 = "MTcyOTc5NjQwMDAwMA==";
  if (true) {
    if (releaseInfo3 === "__RELEASE_INFO__") {
      return ponyfillGlobal_default.__MUI_RELEASE_INFO__;
    }
  }
  return releaseInfo3;
};

// node_modules/@mui/x-charts-pro/ChartContainerPro/ChartContainerPro.js
var React64 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsSurface/ChartsSurface.js
var import_prop_types12 = __toESM(require_prop_types());
var React59 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/hooks/useAxisEvents.js
var React58 = __toESM(require_react());
function getAsANumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
var useAxisEvents = (disableAxisListener) => {
  const svgRef = useSvgRef();
  const drawingArea = useDrawingArea();
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    dispatch
  } = React58.useContext(InteractionContext);
  const usedXAxis = xAxisIds[0];
  const usedYAxis = yAxisIds[0];
  const mousePosition = React58.useRef({
    isInChart: false,
    x: -1,
    y: -1
  });
  React58.useEffect(() => {
    const element = svgRef.current;
    if (element === null || disableAxisListener) {
      return () => {
      };
    }
    function getNewAxisState(axisConfig, mouseValue) {
      const {
        scale,
        data: axisData,
        reverse
      } = axisConfig;
      if (!isBandScale(scale)) {
        const value = scale.invert(mouseValue);
        if (axisData === void 0) {
          return {
            value,
            index: -1
          };
        }
        const valueAsNumber = getAsANumber(value);
        const closestIndex = axisData == null ? void 0 : axisData.findIndex((pointValue, index) => {
          const v = getAsANumber(pointValue);
          if (v > valueAsNumber) {
            if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {
              return true;
            }
          }
          if (v <= valueAsNumber) {
            if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {
              return true;
            }
          }
          return false;
        });
        return {
          value: closestIndex !== void 0 && closestIndex >= 0 ? axisData[closestIndex] : value,
          index: closestIndex
        };
      }
      const dataIndex = scale.bandwidth() === 0 ? Math.floor((mouseValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((mouseValue - Math.min(...scale.range())) / scale.step());
      if (dataIndex < 0 || dataIndex >= axisData.length) {
        return null;
      }
      if (reverse) {
        const reverseIndex = axisData.length - 1 - dataIndex;
        return {
          index: reverseIndex,
          value: axisData[reverseIndex]
        };
      }
      return {
        index: dataIndex,
        value: axisData[dataIndex]
      };
    }
    const handleOut = () => {
      mousePosition.current = {
        isInChart: false,
        x: -1,
        y: -1
      };
      dispatch({
        type: "exitChart"
      });
    };
    const handleMove = (event) => {
      const target = "targetTouches" in event ? event.targetTouches[0] : event;
      const svgPoint = getSVGPoint(element, target);
      mousePosition.current.x = svgPoint.x;
      mousePosition.current.y = svgPoint.y;
      if (!drawingArea.isPointInside(svgPoint, {
        targetElement: event.target
      })) {
        if (mousePosition.current.isInChart) {
          dispatch({
            type: "exitChart"
          });
          mousePosition.current.isInChart = false;
        }
        return;
      }
      mousePosition.current.isInChart = true;
      const newStateX = getNewAxisState(xAxis[usedXAxis], svgPoint.x);
      const newStateY = getNewAxisState(yAxis[usedYAxis], svgPoint.y);
      dispatch({
        type: "updateAxis",
        data: {
          x: newStateX,
          y: newStateY
        }
      });
    };
    const handleDown = (event) => {
      const target = event.currentTarget;
      if (!target) {
        return;
      }
      if (target.hasPointerCapture(event.pointerId)) {
        target.releasePointerCapture(event.pointerId);
      }
    };
    element.addEventListener("pointerdown", handleDown);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointerout", handleOut);
    element.addEventListener("pointercancel", handleOut);
    element.addEventListener("pointerleave", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleDown);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointerout", handleOut);
      element.removeEventListener("pointercancel", handleOut);
      element.removeEventListener("pointerleave", handleOut);
    };
  }, [svgRef, dispatch, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener, drawingArea]);
};

// node_modules/@mui/x-charts-pro/node_modules/@mui/x-charts/ChartsSurface/ChartsSurface.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var _excluded10 = ["children", "width", "height", "viewBox", "disableAxisListener", "className", "title", "desc"];
var ChartChartsSurfaceStyles = styled_default("svg", {
  name: "MuiChartsSurface",
  slot: "Root"
})(() => ({
  // This prevents default touch actions when using the svg on mobile devices.
  // For example, prevent page scroll & zoom.
  touchAction: "none"
}));
var ChartsSurface = React59.forwardRef(function ChartsSurface2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsSurface"
  });
  const {
    children,
    width,
    height,
    viewBox,
    disableAxisListener = false,
    className,
    title,
    desc
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
  const svgView = _extends({
    width,
    height,
    x: 0,
    y: 0
  }, viewBox);
  useAxisEvents(disableAxisListener);
  return (0, import_jsx_runtime27.jsxs)(ChartChartsSurfaceStyles, _extends({
    width,
    height,
    viewBox: `${svgView.x} ${svgView.y} ${svgView.width} ${svgView.height}`,
    ref,
    className
  }, other, {
    children: [(0, import_jsx_runtime27.jsx)("title", {
      children: title
    }), (0, import_jsx_runtime27.jsx)("desc", {
      children: desc
    }), children]
  }));
});
true ? ChartsSurface.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types12.default.node,
  className: import_prop_types12.default.string,
  desc: import_prop_types12.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types12.default.bool,
  /**
   * The height of the chart in px.
   */
  height: import_prop_types12.default.number.isRequired,
  sx: import_prop_types12.default.oneOfType([import_prop_types12.default.arrayOf(import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object, import_prop_types12.default.bool])), import_prop_types12.default.func, import_prop_types12.default.object]),
  title: import_prop_types12.default.string,
  viewBox: import_prop_types12.default.shape({
    height: import_prop_types12.default.number,
    width: import_prop_types12.default.number,
    x: import_prop_types12.default.number,
    y: import_prop_types12.default.number
  }),
  /**
   * The width of the chart in px.
   */
  width: import_prop_types12.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts-pro/context/CartesianProviderPro/CartesianProviderPro.js
var React62 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/context/ZoomProvider/useZoom.js
var React61 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/context/ZoomProvider/ZoomContext.js
var React60 = __toESM(require_react());
var ZoomContext = React60.createContext({
  isInitialized: false,
  data: {
    isZoomEnabled: false,
    isPanEnabled: false,
    options: {},
    zoomData: [],
    setZoomData: () => {
    },
    isInteracting: false,
    setIsInteracting: () => {
    }
  }
});
if (true) {
  ZoomContext.displayName = "ZoomContext";
}

// node_modules/@mui/x-charts-pro/context/ZoomProvider/useZoom.js
function useZoom() {
  const {
    data,
    isInitialized
  } = React61.useContext(ZoomContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the zoom context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}

// node_modules/@mui/x-charts-pro/context/CartesianProviderPro/createAxisFilterMapper.js
var createAxisFilterMapper = ({
  zoomData,
  extremumGetter,
  formattedSeries,
  direction
}) => (axis, axisIndex) => {
  var _a;
  if (typeof axis.zoom !== "object" || axis.zoom.filterMode !== "discard") {
    return null;
  }
  const zoom = zoomData == null ? void 0 : zoomData.find(({
    axisId
  }) => axisId === axis.id);
  if (zoom === void 0 || zoom.start <= 0 && zoom.end >= 100) {
    return null;
  }
  let extremums = [];
  const scaleType = axis.scaleType;
  if (scaleType === "point" || scaleType === "band") {
    extremums = [0, (((_a = axis.data) == null ? void 0 : _a.length) ?? 1) - 1];
  } else {
    extremums = getAxisExtremum(axis, extremumGetter, axisIndex, formattedSeries);
  }
  let min;
  let max;
  [min, max] = getScale(scaleType, extremums, [0, 100]).nice().domain();
  min = min instanceof Date ? min.getTime() : min;
  max = max instanceof Date ? max.getTime() : max;
  const minVal = min + zoom.start * (max - min) / 100;
  const maxVal = min + zoom.end * (max - min) / 100;
  return (value, dataIndex) => {
    var _a2;
    const val = value[direction] ?? ((_a2 = axis.data) == null ? void 0 : _a2[dataIndex]);
    if (val == null) {
      return true;
    }
    if (axis.scaleType === "point" || axis.scaleType === "band" || typeof val === "string") {
      return dataIndex >= minVal && dataIndex <= maxVal;
    }
    return val >= minVal && val <= maxVal;
  };
};
var createGetAxisFilters = (filters) => ({
  currentAxisId,
  seriesXAxisId,
  seriesYAxisId,
  isDefaultAxis
}) => {
  return (value, dataIndex) => {
    var _a, _b;
    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;
    if (!axisId || isDefaultAxis) {
      return ((_b = (_a = Object.values(filters ?? {}))[0]) == null ? void 0 : _b.call(_a, value, dataIndex)) ?? true;
    }
    const data = [seriesYAxisId, seriesXAxisId].filter((id) => id !== currentAxisId).map((id) => filters[id ?? ""]).filter(isDefined);
    return data.every((f) => f(value, dataIndex));
  };
};

// node_modules/@mui/x-charts-pro/context/CartesianProviderPro/CartesianProviderPro.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
function CartesianProviderPro(props) {
  const {
    xAxis,
    yAxis,
    children
  } = props;
  const formattedSeries = useSeries();
  const drawingArea = useDrawingArea();
  const {
    zoomData,
    options
  } = useZoom();
  const xExtremumGetters = useXExtremumGetter();
  const yExtremumGetters = useYExtremumGetter();
  const getFilters = React62.useMemo(() => {
    const xMapper = createAxisFilterMapper({
      zoomData,
      extremumGetter: xExtremumGetters,
      formattedSeries,
      direction: "x"
    });
    const yMapper = createAxisFilterMapper({
      zoomData,
      extremumGetter: yExtremumGetters,
      formattedSeries,
      direction: "y"
    });
    const xFilters = xAxis.reduce((acc, axis, index) => {
      const filter = xMapper(axis, index);
      if (filter !== null) {
        acc[axis.id] = filter;
      }
      return acc;
    }, {});
    const yFilters = yAxis.reduce((acc, axis, index) => {
      const filter = yMapper(axis, index);
      if (filter !== null) {
        acc[axis.id] = filter;
      }
      return acc;
    }, {});
    if (Object.keys(xFilters).length === 0 && Object.keys(yFilters).length === 0) {
      return void 0;
    }
    return createGetAxisFilters(_extends({}, xFilters, yFilters));
  }, [formattedSeries, xAxis, xExtremumGetters, yAxis, yExtremumGetters, zoomData]);
  const xValues = React62.useMemo(() => computeAxisValue({
    drawingArea,
    formattedSeries,
    axis: xAxis,
    extremumGetters: xExtremumGetters,
    axisDirection: "x",
    zoomData,
    zoomOptions: options,
    getFilters
  }), [drawingArea, formattedSeries, xAxis, xExtremumGetters, zoomData, options, getFilters]);
  const yValues = React62.useMemo(() => computeAxisValue({
    drawingArea,
    formattedSeries,
    axis: yAxis,
    extremumGetters: yExtremumGetters,
    axisDirection: "y",
    zoomData,
    zoomOptions: options,
    getFilters
  }), [drawingArea, formattedSeries, yAxis, yExtremumGetters, zoomData, options, getFilters]);
  const value = React62.useMemo(() => ({
    isInitialized: true,
    data: {
      xAxis: xValues.axis,
      yAxis: yValues.axis,
      xAxisIds: xValues.axisIds,
      yAxisIds: yValues.axisIds
    }
  }), [xValues, yValues]);
  return (0, import_jsx_runtime28.jsx)(CartesianContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts-pro/context/ZoomProvider/ZoomProvider.js
var React63 = __toESM(require_react());

// node_modules/@mui/x-charts-pro/context/ZoomProvider/defaultizeZoom.js
var defaultZoomOptions = {
  minStart: 0,
  maxEnd: 100,
  step: 5,
  minSpan: 10,
  maxSpan: 100,
  panning: true,
  filterMode: "keep"
};
var defaultizeZoom = (axis, axisDirection) => {
  if (!axis) {
    return [];
  }
  const defaultized = axis.map((v) => {
    if (!v.zoom) {
      return void 0;
    }
    if (v.zoom === true) {
      return _extends({
        axisId: v.id,
        axisDirection
      }, defaultZoomOptions);
    }
    return _extends({
      axisId: v.id,
      axisDirection
    }, defaultZoomOptions, v.zoom);
  }).filter(isDefined);
  return defaultized;
};

// node_modules/@mui/x-charts-pro/context/ZoomProvider/initializeZoomData.js
var initializeZoomData = (options) => {
  return Object.values(options).map(({
    axisId,
    minStart: start,
    maxEnd: end
  }) => ({
    axisId,
    start,
    end
  }));
};

// node_modules/@mui/x-charts-pro/context/ZoomProvider/ZoomProvider.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
function ZoomProvider({
  children,
  xAxis,
  yAxis,
  zoom,
  onZoomChange
}) {
  const [isInteracting, setIsInteracting] = React63.useState(false);
  const options = React63.useMemo(() => [...defaultizeZoom(xAxis, "x"), ...defaultizeZoom(yAxis, "y")].reduce((acc, v) => {
    acc[v.axisId] = v;
    return acc;
  }, {}), [xAxis, yAxis]);
  const defaultZoomData = React63.useRef(initializeZoomData(options));
  const [zoomData, setZoomData] = useControlled({
    controlled: zoom,
    default: defaultZoomData.current,
    name: "ZoomProvider",
    state: "zoom"
  });
  const setZoomDataCallback = React63.useCallback((newZoomData) => {
    setZoomData(newZoomData);
    onZoomChange == null ? void 0 : onZoomChange(newZoomData);
  }, [setZoomData, onZoomChange]);
  const value = React63.useMemo(() => ({
    isInitialized: true,
    data: {
      isZoomEnabled: Object.keys(options).length > 0,
      isPanEnabled: isPanEnabled(options),
      options,
      zoomData,
      setZoomData: setZoomDataCallback,
      isInteracting,
      setIsInteracting
    }
  }), [zoomData, isInteracting, setIsInteracting, options, setZoomDataCallback]);
  return (0, import_jsx_runtime29.jsx)(ZoomContext.Provider, {
    value,
    children
  });
}
function isPanEnabled(options) {
  return Object.values(options).some((v) => v.panning) || false;
}

// node_modules/@mui/x-charts-pro/ChartContainerPro/useChartContainerProProps.js
var _excluded11 = ["zoom", "onZoomChange"];
var useChartContainerProProps = (props, ref) => {
  const {
    zoom,
    onZoomChange
  } = props, baseProps = _objectWithoutPropertiesLoose(props, _excluded11);
  const {
    children,
    drawingProviderProps,
    seriesProviderProps,
    cartesianProviderProps,
    zAxisContextProps,
    highlightedProviderProps,
    chartsSurfaceProps,
    pluginProviderProps,
    animationProviderProps,
    xAxis,
    yAxis
  } = useChartContainerProps(baseProps, ref);
  const zoomProviderProps = {
    zoom,
    onZoomChange,
    xAxis,
    yAxis
  };
  return {
    zoomProviderProps,
    children,
    drawingProviderProps,
    pluginProviderProps,
    seriesProviderProps,
    cartesianProviderProps,
    zAxisContextProps,
    highlightedProviderProps,
    chartsSurfaceProps,
    animationProviderProps
  };
};

// node_modules/@mui/x-charts-pro/ChartContainerPro/ChartContainerPro.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var releaseInfo = getReleaseInfo();
var ChartContainerPro = React64.forwardRef(function ChartContainer(props, ref) {
  const {
    zoomProviderProps,
    drawingProviderProps,
    seriesProviderProps,
    zAxisContextProps,
    highlightedProviderProps,
    cartesianProviderProps,
    chartsSurfaceProps,
    pluginProviderProps,
    animationProviderProps,
    children
  } = useChartContainerProProps(props, ref);
  useLicenseVerifier("x-charts-pro", releaseInfo);
  return (0, import_jsx_runtime30.jsx)(DrawingProvider, _extends({}, drawingProviderProps, {
    children: (0, import_jsx_runtime30.jsx)(AnimationProvider, _extends({}, animationProviderProps, {
      children: (0, import_jsx_runtime30.jsx)(PluginProvider, _extends({}, pluginProviderProps, {
        children: (0, import_jsx_runtime30.jsx)(ZoomProvider, _extends({}, zoomProviderProps, {
          children: (0, import_jsx_runtime30.jsx)(SeriesProvider, _extends({}, seriesProviderProps, {
            children: (0, import_jsx_runtime30.jsx)(CartesianProviderPro, _extends({}, cartesianProviderProps, {
              children: (0, import_jsx_runtime30.jsx)(ZAxisContextProvider, _extends({}, zAxisContextProps, {
                children: (0, import_jsx_runtime30.jsx)(InteractionProvider, {
                  children: (0, import_jsx_runtime30.jsx)(HighlightedProvider, _extends({}, highlightedProviderProps, {
                    children: (0, import_jsx_runtime30.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
                      children: [(0, import_jsx_runtime30.jsx)(ChartsAxesGradients, {}), children]
                    }))
                  }))
                })
              }))
            }))
          }))
        }))
      }))
    }))
  }));
});
true ? ChartContainerPro.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types13.default.node,
  className: import_prop_types13.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.string), import_prop_types13.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types13.default.arrayOf(import_prop_types13.default.object),
  desc: import_prop_types13.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types13.default.bool,
  /**
   * The height of the chart in px.
   */
  height: import_prop_types13.default.number.isRequired,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types13.default.shape({
    dataIndex: import_prop_types13.default.number,
    seriesId: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types13.default.shape({
    bottom: import_prop_types13.default.number,
    left: import_prop_types13.default.number,
    right: import_prop_types13.default.number,
    top: import_prop_types13.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types13.default.func,
  /**
   * Callback fired when the zoom has changed.
   *
   * @param {ZoomData[]} zoomData Updated zoom data.
   */
  onZoomChange: import_prop_types13.default.func,
  /**
   * An array of plugins defining how to preprocess data.
   * If not provided, the container supports line, bar, scatter and pie charts.
   */
  plugins: import_prop_types13.default.arrayOf(import_prop_types13.default.object),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types13.default.arrayOf(import_prop_types13.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types13.default.bool,
  sx: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object, import_prop_types13.default.bool])), import_prop_types13.default.func, import_prop_types13.default.object]),
  title: import_prop_types13.default.string,
  viewBox: import_prop_types13.default.shape({
    height: import_prop_types13.default.number,
    width: import_prop_types13.default.number,
    x: import_prop_types13.default.number,
    y: import_prop_types13.default.number
  }),
  /**
   * The width of the chart in px.
   */
  width: import_prop_types13.default.number.isRequired,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types13.default.arrayOf(import_prop_types13.default.shape({
    classes: import_prop_types13.default.object,
    colorMap: import_prop_types13.default.oneOfType([import_prop_types13.default.shape({
      colors: import_prop_types13.default.arrayOf(import_prop_types13.default.string).isRequired,
      type: import_prop_types13.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types13.default.string,
      values: import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number, import_prop_types13.default.string]).isRequired)
    }), import_prop_types13.default.shape({
      color: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.string.isRequired), import_prop_types13.default.func]).isRequired,
      max: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
      min: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
      type: import_prop_types13.default.oneOf(["continuous"]).isRequired
    }), import_prop_types13.default.shape({
      colors: import_prop_types13.default.arrayOf(import_prop_types13.default.string).isRequired,
      thresholds: import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]).isRequired).isRequired,
      type: import_prop_types13.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types13.default.array,
    dataKey: import_prop_types13.default.string,
    disableLine: import_prop_types13.default.bool,
    disableTicks: import_prop_types13.default.bool,
    fill: import_prop_types13.default.string,
    hideTooltip: import_prop_types13.default.bool,
    id: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string]),
    label: import_prop_types13.default.string,
    labelFontSize: import_prop_types13.default.number,
    labelStyle: import_prop_types13.default.object,
    max: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
    min: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
    position: import_prop_types13.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types13.default.bool,
    scaleType: import_prop_types13.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types13.default.object,
    slots: import_prop_types13.default.object,
    stroke: import_prop_types13.default.string,
    sx: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object, import_prop_types13.default.bool])), import_prop_types13.default.func, import_prop_types13.default.object]),
    tickFontSize: import_prop_types13.default.number,
    tickInterval: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["auto"]), import_prop_types13.default.array, import_prop_types13.default.func]),
    tickLabelInterval: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["auto"]), import_prop_types13.default.func]),
    tickLabelPlacement: import_prop_types13.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types13.default.object,
    tickMaxStep: import_prop_types13.default.number,
    tickMinStep: import_prop_types13.default.number,
    tickNumber: import_prop_types13.default.number,
    tickPlacement: import_prop_types13.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types13.default.number,
    valueFormatter: import_prop_types13.default.func,
    zoom: import_prop_types13.default.oneOfType([import_prop_types13.default.shape({
      filterMode: import_prop_types13.default.oneOf(["discard", "keep"]),
      maxEnd: import_prop_types13.default.number,
      maxSpan: import_prop_types13.default.number,
      minSpan: import_prop_types13.default.number,
      minStart: import_prop_types13.default.number,
      panning: import_prop_types13.default.bool,
      step: import_prop_types13.default.number
    }), import_prop_types13.default.bool])
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types13.default.arrayOf(import_prop_types13.default.shape({
    classes: import_prop_types13.default.object,
    colorMap: import_prop_types13.default.oneOfType([import_prop_types13.default.shape({
      colors: import_prop_types13.default.arrayOf(import_prop_types13.default.string).isRequired,
      type: import_prop_types13.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types13.default.string,
      values: import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number, import_prop_types13.default.string]).isRequired)
    }), import_prop_types13.default.shape({
      color: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.string.isRequired), import_prop_types13.default.func]).isRequired,
      max: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
      min: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
      type: import_prop_types13.default.oneOf(["continuous"]).isRequired
    }), import_prop_types13.default.shape({
      colors: import_prop_types13.default.arrayOf(import_prop_types13.default.string).isRequired,
      thresholds: import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]).isRequired).isRequired,
      type: import_prop_types13.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types13.default.array,
    dataKey: import_prop_types13.default.string,
    disableLine: import_prop_types13.default.bool,
    disableTicks: import_prop_types13.default.bool,
    fill: import_prop_types13.default.string,
    hideTooltip: import_prop_types13.default.bool,
    id: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string]),
    label: import_prop_types13.default.string,
    labelFontSize: import_prop_types13.default.number,
    labelStyle: import_prop_types13.default.object,
    max: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
    min: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
    position: import_prop_types13.default.oneOf(["left", "right"]),
    reverse: import_prop_types13.default.bool,
    scaleType: import_prop_types13.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types13.default.object,
    slots: import_prop_types13.default.object,
    stroke: import_prop_types13.default.string,
    sx: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object, import_prop_types13.default.bool])), import_prop_types13.default.func, import_prop_types13.default.object]),
    tickFontSize: import_prop_types13.default.number,
    tickInterval: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["auto"]), import_prop_types13.default.array, import_prop_types13.default.func]),
    tickLabelInterval: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["auto"]), import_prop_types13.default.func]),
    tickLabelPlacement: import_prop_types13.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types13.default.object,
    tickMaxStep: import_prop_types13.default.number,
    tickMinStep: import_prop_types13.default.number,
    tickNumber: import_prop_types13.default.number,
    tickPlacement: import_prop_types13.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types13.default.number,
    valueFormatter: import_prop_types13.default.func,
    zoom: import_prop_types13.default.oneOfType([import_prop_types13.default.shape({
      filterMode: import_prop_types13.default.oneOf(["discard", "keep"]),
      maxEnd: import_prop_types13.default.number,
      maxSpan: import_prop_types13.default.number,
      minSpan: import_prop_types13.default.number,
      minStart: import_prop_types13.default.number,
      panning: import_prop_types13.default.bool,
      step: import_prop_types13.default.number
    }), import_prop_types13.default.bool])
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types13.default.arrayOf(import_prop_types13.default.shape({
    colorMap: import_prop_types13.default.oneOfType([import_prop_types13.default.shape({
      colors: import_prop_types13.default.arrayOf(import_prop_types13.default.string).isRequired,
      type: import_prop_types13.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types13.default.string,
      values: import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number, import_prop_types13.default.string]).isRequired)
    }), import_prop_types13.default.shape({
      color: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.string.isRequired), import_prop_types13.default.func]).isRequired,
      max: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
      min: import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]),
      type: import_prop_types13.default.oneOf(["continuous"]).isRequired
    }), import_prop_types13.default.shape({
      colors: import_prop_types13.default.arrayOf(import_prop_types13.default.string).isRequired,
      thresholds: import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.instanceOf(Date), import_prop_types13.default.number]).isRequired).isRequired,
      type: import_prop_types13.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types13.default.array,
    dataKey: import_prop_types13.default.string,
    id: import_prop_types13.default.string,
    max: import_prop_types13.default.number,
    min: import_prop_types13.default.number
  })),
  /**
   * The list of zoom data related to each axis.
   */
  zoom: import_prop_types13.default.arrayOf(import_prop_types13.default.shape({
    axisId: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string]).isRequired,
    end: import_prop_types13.default.number.isRequired,
    start: import_prop_types13.default.number.isRequired
  }))
} : void 0;

// node_modules/@mui/x-charts-pro/ResponsiveChartContainerPro/useResponsiveChartContainerProProps.js
var _excluded12 = ["zoom", "onZoomChange"];
var useResponsiveChartContainerProProps = (props, ref) => {
  const {
    zoom,
    onZoomChange
  } = props, baseProps = _objectWithoutPropertiesLoose(props, _excluded12);
  const chartContainerProProps = {
    zoom,
    onZoomChange
  };
  const {
    chartContainerProps,
    resizableChartContainerProps,
    hasIntrinsicSize
  } = useResponsiveChartContainerProps(baseProps, ref);
  return {
    chartContainerProProps: _extends({}, chartContainerProps, chartContainerProProps),
    resizableChartContainerProps,
    hasIntrinsicSize
  };
};

// node_modules/@mui/x-charts-pro/ResponsiveChartContainerPro/ResponsiveChartContainerPro.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var releaseInfo2 = getReleaseInfo();
var ResponsiveChartContainerPro = React65.forwardRef(function ResponsiveChartContainerPro2(props, ref) {
  const {
    chartContainerProProps,
    resizableChartContainerProps,
    hasIntrinsicSize
  } = useResponsiveChartContainerProProps(props, ref);
  return (0, import_jsx_runtime31.jsxs)(ResizableContainer, _extends({}, resizableChartContainerProps, {
    children: [hasIntrinsicSize ? (0, import_jsx_runtime31.jsx)(ChartContainerPro, _extends({}, chartContainerProProps)) : null, (0, import_jsx_runtime31.jsx)(Watermark, {
      packageName: "x-charts-pro",
      releaseInfo: releaseInfo2
    })]
  }));
});
true ? ResponsiveChartContainerPro.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types14.default.node,
  className: import_prop_types14.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.string), import_prop_types14.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types14.default.arrayOf(import_prop_types14.default.object),
  desc: import_prop_types14.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types14.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types14.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types14.default.shape({
    dataIndex: import_prop_types14.default.number,
    seriesId: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types14.default.shape({
    bottom: import_prop_types14.default.number,
    left: import_prop_types14.default.number,
    right: import_prop_types14.default.number,
    top: import_prop_types14.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types14.default.func,
  /**
   * Callback fired when the zoom has changed.
   *
   * @param {ZoomData[]} zoomData Updated zoom data.
   */
  onZoomChange: import_prop_types14.default.func,
  /**
   * An array of plugins defining how to preprocess data.
   * If not provided, the container supports line, bar, scatter and pie charts.
   */
  plugins: import_prop_types14.default.arrayOf(import_prop_types14.default.object),
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types14.default.bool,
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types14.default.arrayOf(import_prop_types14.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types14.default.bool,
  sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object]),
  title: import_prop_types14.default.string,
  viewBox: import_prop_types14.default.shape({
    height: import_prop_types14.default.number,
    width: import_prop_types14.default.number,
    x: import_prop_types14.default.number,
    y: import_prop_types14.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types14.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types14.default.arrayOf(import_prop_types14.default.shape({
    classes: import_prop_types14.default.object,
    colorMap: import_prop_types14.default.oneOfType([import_prop_types14.default.shape({
      colors: import_prop_types14.default.arrayOf(import_prop_types14.default.string).isRequired,
      type: import_prop_types14.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types14.default.string,
      values: import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number, import_prop_types14.default.string]).isRequired)
    }), import_prop_types14.default.shape({
      color: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.string.isRequired), import_prop_types14.default.func]).isRequired,
      max: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
      min: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
      type: import_prop_types14.default.oneOf(["continuous"]).isRequired
    }), import_prop_types14.default.shape({
      colors: import_prop_types14.default.arrayOf(import_prop_types14.default.string).isRequired,
      thresholds: import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]).isRequired).isRequired,
      type: import_prop_types14.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types14.default.array,
    dataKey: import_prop_types14.default.string,
    disableLine: import_prop_types14.default.bool,
    disableTicks: import_prop_types14.default.bool,
    fill: import_prop_types14.default.string,
    hideTooltip: import_prop_types14.default.bool,
    id: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]),
    label: import_prop_types14.default.string,
    labelFontSize: import_prop_types14.default.number,
    labelStyle: import_prop_types14.default.object,
    max: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
    min: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
    position: import_prop_types14.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types14.default.bool,
    scaleType: import_prop_types14.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types14.default.object,
    slots: import_prop_types14.default.object,
    stroke: import_prop_types14.default.string,
    sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object]),
    tickFontSize: import_prop_types14.default.number,
    tickInterval: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["auto"]), import_prop_types14.default.array, import_prop_types14.default.func]),
    tickLabelInterval: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["auto"]), import_prop_types14.default.func]),
    tickLabelPlacement: import_prop_types14.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types14.default.object,
    tickMaxStep: import_prop_types14.default.number,
    tickMinStep: import_prop_types14.default.number,
    tickNumber: import_prop_types14.default.number,
    tickPlacement: import_prop_types14.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types14.default.number,
    valueFormatter: import_prop_types14.default.func,
    zoom: import_prop_types14.default.oneOfType([import_prop_types14.default.shape({
      filterMode: import_prop_types14.default.oneOf(["discard", "keep"]),
      maxEnd: import_prop_types14.default.number,
      maxSpan: import_prop_types14.default.number,
      minSpan: import_prop_types14.default.number,
      minStart: import_prop_types14.default.number,
      panning: import_prop_types14.default.bool,
      step: import_prop_types14.default.number
    }), import_prop_types14.default.bool])
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types14.default.arrayOf(import_prop_types14.default.shape({
    classes: import_prop_types14.default.object,
    colorMap: import_prop_types14.default.oneOfType([import_prop_types14.default.shape({
      colors: import_prop_types14.default.arrayOf(import_prop_types14.default.string).isRequired,
      type: import_prop_types14.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types14.default.string,
      values: import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number, import_prop_types14.default.string]).isRequired)
    }), import_prop_types14.default.shape({
      color: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.string.isRequired), import_prop_types14.default.func]).isRequired,
      max: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
      min: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
      type: import_prop_types14.default.oneOf(["continuous"]).isRequired
    }), import_prop_types14.default.shape({
      colors: import_prop_types14.default.arrayOf(import_prop_types14.default.string).isRequired,
      thresholds: import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]).isRequired).isRequired,
      type: import_prop_types14.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types14.default.array,
    dataKey: import_prop_types14.default.string,
    disableLine: import_prop_types14.default.bool,
    disableTicks: import_prop_types14.default.bool,
    fill: import_prop_types14.default.string,
    hideTooltip: import_prop_types14.default.bool,
    id: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]),
    label: import_prop_types14.default.string,
    labelFontSize: import_prop_types14.default.number,
    labelStyle: import_prop_types14.default.object,
    max: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
    min: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
    position: import_prop_types14.default.oneOf(["left", "right"]),
    reverse: import_prop_types14.default.bool,
    scaleType: import_prop_types14.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types14.default.object,
    slots: import_prop_types14.default.object,
    stroke: import_prop_types14.default.string,
    sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object]),
    tickFontSize: import_prop_types14.default.number,
    tickInterval: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["auto"]), import_prop_types14.default.array, import_prop_types14.default.func]),
    tickLabelInterval: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["auto"]), import_prop_types14.default.func]),
    tickLabelPlacement: import_prop_types14.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types14.default.object,
    tickMaxStep: import_prop_types14.default.number,
    tickMinStep: import_prop_types14.default.number,
    tickNumber: import_prop_types14.default.number,
    tickPlacement: import_prop_types14.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types14.default.number,
    valueFormatter: import_prop_types14.default.func,
    zoom: import_prop_types14.default.oneOfType([import_prop_types14.default.shape({
      filterMode: import_prop_types14.default.oneOf(["discard", "keep"]),
      maxEnd: import_prop_types14.default.number,
      maxSpan: import_prop_types14.default.number,
      minSpan: import_prop_types14.default.number,
      minStart: import_prop_types14.default.number,
      panning: import_prop_types14.default.bool,
      step: import_prop_types14.default.number
    }), import_prop_types14.default.bool])
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types14.default.arrayOf(import_prop_types14.default.shape({
    colorMap: import_prop_types14.default.oneOfType([import_prop_types14.default.shape({
      colors: import_prop_types14.default.arrayOf(import_prop_types14.default.string).isRequired,
      type: import_prop_types14.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types14.default.string,
      values: import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number, import_prop_types14.default.string]).isRequired)
    }), import_prop_types14.default.shape({
      color: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.string.isRequired), import_prop_types14.default.func]).isRequired,
      max: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
      min: import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]),
      type: import_prop_types14.default.oneOf(["continuous"]).isRequired
    }), import_prop_types14.default.shape({
      colors: import_prop_types14.default.arrayOf(import_prop_types14.default.string).isRequired,
      thresholds: import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.instanceOf(Date), import_prop_types14.default.number]).isRequired).isRequired,
      type: import_prop_types14.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types14.default.array,
    dataKey: import_prop_types14.default.string,
    id: import_prop_types14.default.string,
    max: import_prop_types14.default.number,
    min: import_prop_types14.default.number
  })),
  /**
   * The list of zoom data related to each axis.
   */
  zoom: import_prop_types14.default.arrayOf(import_prop_types14.default.shape({
    axisId: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]).isRequired,
    end: import_prop_types14.default.number.isRequired,
    start: import_prop_types14.default.number.isRequired
  }))
} : void 0;

// node_modules/@mui/x-charts-pro/Heatmap/HeatmapPlot.js
var React68 = __toESM(require_react());
var import_prop_types16 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/hooks/useSeries.js
var React66 = __toESM(require_react());
function useHeatmapSeries() {
  const series = useSeries();
  return React66.useMemo(() => series.heatmap, [series.heatmap]);
}

// node_modules/@mui/x-charts-pro/Heatmap/HeatmapItem.js
var React67 = __toESM(require_react());
var import_prop_types15 = __toESM(require_prop_types());

// node_modules/@mui/x-charts-pro/Heatmap/heatmapClasses.js
function getHeatmapUtilityClass(slot) {
  if (["highlighted", "faded"].includes(slot)) {
    return generateUtilityClass("Charts", slot);
  }
  return generateUtilityClass("MuiHeatmap", slot);
}
var heatmapClasses = _extends({}, generateUtilityClasses("MuiHeatmap", ["cell"]), {
  highlighted: "Charts-highlighted",
  faded: "Charts-faded"
});

// node_modules/@mui/x-charts-pro/Heatmap/HeatmapItem.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var _excluded13 = ["seriesId", "dataIndex", "color", "value", "slotProps", "slots"];
var HeatmapCell = styled_default("rect", {
  name: "MuiHeatmap",
  slot: "Cell",
  overridesResolver: (_, styles) => styles.arc
})(({
  ownerState
}) => ({
  filter: ownerState.isHighlighted && "saturate(120%)" || ownerState.isFaded && "saturate(80%)" || void 0,
  fill: ownerState.color,
  shapeRendering: "crispEdges"
}));
var useUtilityClasses4 = (ownerState) => {
  const {
    classes,
    seriesId,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    cell: ["cell", `series-${seriesId}`, isFaded && "faded", isHighlighted && "highlighted"]
  };
  return composeClasses(slots, getHeatmapUtilityClass, classes);
};
function HeatmapItem(props) {
  const {
    seriesId,
    dataIndex,
    color,
    value,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId,
    dataIndex
  });
  const ownerState = {
    seriesId,
    dataIndex,
    color,
    value,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses4(ownerState);
  const Cell = (slots == null ? void 0 : slots.cell) ?? HeatmapCell;
  const cellProps = useSlotProps_default({
    elementType: Cell,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "heatmap",
      seriesId,
      dataIndex
    })),
    externalForwardedProps: _extends({}, other),
    externalSlotProps: slotProps.cell,
    ownerState,
    className: classes.cell
  });
  return (0, import_jsx_runtime32.jsx)(Cell, _extends({}, cellProps));
}
true ? HeatmapItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  color: import_prop_types15.default.string.isRequired,
  dataIndex: import_prop_types15.default.number.isRequired,
  height: import_prop_types15.default.number.isRequired,
  seriesId: import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types15.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types15.default.object,
  value: import_prop_types15.default.number.isRequired,
  width: import_prop_types15.default.number.isRequired,
  x: import_prop_types15.default.number.isRequired,
  y: import_prop_types15.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts-pro/Heatmap/HeatmapPlot.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
function HeatmapPlot(props) {
  const xScale = useXScale();
  const yScale = useYScale();
  const colorScale = useZColorScale();
  const series = useHeatmapSeries();
  const xDomain = xScale.domain();
  const yDomain = yScale.domain();
  if (!series || series.seriesOrder.length === 0) {
    return null;
  }
  const seriesToDisplay = series.series[series.seriesOrder[0]];
  return (0, import_jsx_runtime33.jsx)("g", {
    children: seriesToDisplay.data.map(([xIndex, yIndex, value], dataIndex) => {
      const x = xScale(xDomain[xIndex]);
      const y = yScale(yDomain[yIndex]);
      const color = colorScale == null ? void 0 : colorScale(value);
      if (x === void 0 || y === void 0 || !color) {
        return null;
      }
      return (0, import_jsx_runtime33.jsx)(HeatmapItem, {
        width: xScale.bandwidth(),
        height: yScale.bandwidth(),
        x,
        y,
        color,
        dataIndex,
        seriesId: series.seriesOrder[0],
        value,
        slots: props.slots,
        slotProps: props.slotProps
      }, `${xIndex}_${yIndex}`);
    })
  });
}
true ? HeatmapPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types16.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types16.default.object
} : void 0;

// node_modules/@mui/x-charts-pro/Heatmap/extremums.js
var getBaseExtremum2 = (params) => {
  const {
    axis
  } = params;
  const minX = Math.min(...axis.data ?? []);
  const maxX = Math.max(...axis.data ?? []);
  return [minX, maxX];
};

// node_modules/@mui/x-charts-pro/Heatmap/formatter.js
var formatter5 = (params) => {
  const {
    series,
    seriesOrder
  } = params;
  const defaultizedSeries = {};
  Object.keys(series).forEach((seriesId) => {
    defaultizedSeries[seriesId] = _extends({
      // Defaultize the data and the value formatter.
      valueFormatter: (v) => v[2].toString(),
      data: []
    }, series[seriesId]);
  });
  return {
    series: defaultizedSeries,
    seriesOrder
  };
};
var formatter_default5 = formatter5;

// node_modules/@mui/x-charts-pro/Heatmap/getColor.js
var getColor5 = (series, xAxis, yAxis, zAxis) => {
  const zColorScale = zAxis == null ? void 0 : zAxis.colorScale;
  if (zColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = zColorScale(value[2]);
      if (color === null) {
        return "";
      }
      return color;
    };
  }
  return () => "";
};
var getColor_default5 = getColor5;

// node_modules/@mui/x-charts-pro/Heatmap/plugin.js
var plugin5 = {
  seriesType: "heatmap",
  seriesFormatter: formatter_default5,
  colorProcessor: getColor_default5,
  xExtremumGetter: getBaseExtremum2,
  yExtremumGetter: getBaseExtremum2
};

// node_modules/@mui/x-charts-pro/Heatmap/DefaultHeatmapTooltip.js
var React69 = __toESM(require_react());
var import_prop_types17 = __toESM(require_prop_types());
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
function DefaultHeatmapTooltip(props) {
  var _a, _b;
  const {
    series,
    itemData,
    sx,
    classes,
    getColor: getColor6
  } = props;
  const xAxis = useXAxis();
  const yAxis = useYAxis();
  if (itemData.dataIndex === void 0 || !series.data[itemData.dataIndex]) {
    return null;
  }
  const color = getColor6(itemData.dataIndex);
  const valueItem = series.data[itemData.dataIndex];
  const [xIndex, yIndex] = valueItem;
  const formattedX = ((_a = xAxis.valueFormatter) == null ? void 0 : _a.call(xAxis, xAxis.data[xIndex], {
    location: "tooltip"
  })) ?? xAxis.data[xIndex].toLocaleString();
  const formattedY = ((_b = yAxis.valueFormatter) == null ? void 0 : _b.call(yAxis, yAxis.data[yIndex], {
    location: "tooltip"
  })) ?? yAxis.data[yIndex].toLocaleString();
  const formattedValue = series.valueFormatter(valueItem, {
    dataIndex: itemData.dataIndex
  });
  const seriesLabel = getLabel(series.label, "tooltip");
  return (0, import_jsx_runtime34.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.root,
    children: (0, import_jsx_runtime34.jsxs)(ChartsTooltipTable, {
      className: classes.table,
      children: [(0, import_jsx_runtime34.jsx)("thead", {
        children: (0, import_jsx_runtime34.jsxs)(ChartsTooltipRow, {
          children: [(0, import_jsx_runtime34.jsx)(ChartsTooltipCell, {
            children: formattedX
          }), formattedX && formattedY && (0, import_jsx_runtime34.jsx)(ChartsTooltipCell, {}), (0, import_jsx_runtime34.jsx)(ChartsTooltipCell, {
            children: formattedY
          })]
        })
      }), (0, import_jsx_runtime34.jsx)("tbody", {
        children: (0, import_jsx_runtime34.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime34.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.markCell, classes.cell),
            children: (0, import_jsx_runtime34.jsx)(ChartsTooltipMark, {
              color,
              className: classes.mark
            })
          }), (0, import_jsx_runtime34.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            children: seriesLabel
          }), (0, import_jsx_runtime34.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            children: formattedValue
          })]
        })
      })]
    })
  });
}
true ? DefaultHeatmapTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types17.default.object.isRequired,
  /**
   * Get the color of the item with index `dataIndex`.
   * @param {number} dataIndex The data index of the item.
   * @returns {string} The color to display.
   */
  getColor: import_prop_types17.default.func.isRequired,
  /**
   * The data used to identify the triggered item.
   */
  itemData: import_prop_types17.default.shape({
    dataIndex: import_prop_types17.default.number.isRequired,
    seriesId: import_prop_types17.default.oneOfType([import_prop_types17.default.number, import_prop_types17.default.string]).isRequired,
    type: import_prop_types17.default.oneOf(["heatmap"]).isRequired
  }).isRequired,
  /**
   * The series linked to the triggered item.
   */
  series: import_prop_types17.default.object.isRequired,
  sx: import_prop_types17.default.oneOfType([import_prop_types17.default.arrayOf(import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object, import_prop_types17.default.bool])), import_prop_types17.default.func, import_prop_types17.default.object])
} : void 0;

// node_modules/@mui/x-charts-pro/Heatmap/Heatmap.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var defaultColorMap = rgbBasis(["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]);
var Heatmap = React70.forwardRef(function Heatmap2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiHeatmap"
  });
  const {
    xAxis,
    yAxis,
    zAxis,
    series,
    width,
    height,
    margin,
    colors,
    dataset,
    sx,
    tooltip,
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    onAxisClick,
    children,
    slots,
    slotProps,
    loading,
    highlightedItem,
    onHighlightChange
  } = props;
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const defaultizedXAxis = React70.useMemo(() => xAxis.map((axis) => _extends({
    scaleType: "band",
    categoryGapRatio: 0
  }, axis)), [xAxis]);
  const defaultizedYAxis = React70.useMemo(() => yAxis.map((axis) => _extends({
    scaleType: "band",
    categoryGapRatio: 0
  }, axis)), [yAxis]);
  const defaultizedZAxis = React70.useMemo(() => zAxis ?? [{
    colorMap: {
      type: "continuous",
      min: 0,
      max: 100,
      color: defaultColorMap
    }
  }], [zAxis]);
  return (0, import_jsx_runtime35.jsxs)(ResponsiveChartContainerPro, {
    ref,
    plugins: [plugin5],
    series: series.map((s) => _extends({
      type: "heatmap"
    }, s)),
    width,
    height,
    margin,
    xAxis: defaultizedXAxis,
    yAxis: defaultizedYAxis,
    zAxis: defaultizedZAxis,
    colors,
    dataset,
    sx,
    disableAxisListener: true,
    highlightedItem,
    onHighlightChange,
    children: [onAxisClick && (0, import_jsx_runtime35.jsx)(ChartsOnAxisClickHandler, {
      onAxisClick
    }), (0, import_jsx_runtime35.jsxs)("g", {
      clipPath: `url(#${clipPathId})`,
      children: [(0, import_jsx_runtime35.jsx)(HeatmapPlot, {
        slots,
        slotProps
      }), (0, import_jsx_runtime35.jsx)(ChartsOverlay, {
        loading,
        slots,
        slotProps
      })]
    }), (0, import_jsx_runtime35.jsx)(ChartsAxis, {
      topAxis,
      leftAxis,
      rightAxis,
      bottomAxis,
      slots,
      slotProps
    }), !loading && (0, import_jsx_runtime35.jsx)(ChartsTooltip, _extends({
      trigger: "item"
    }, tooltip, {
      slots: _extends({
        itemContent: DefaultHeatmapTooltip
      }, slots),
      slotProps
    })), (0, import_jsx_runtime35.jsx)(ChartsClipPath, {
      id: clipPathId
    }), children]
  });
});
true ? Heatmap.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types18.default.oneOfType([import_prop_types18.default.object, import_prop_types18.default.string]),
  children: import_prop_types18.default.node,
  className: import_prop_types18.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.string), import_prop_types18.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types18.default.arrayOf(import_prop_types18.default.object),
  desc: import_prop_types18.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types18.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types18.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types18.default.shape({
    dataIndex: import_prop_types18.default.number,
    seriesId: import_prop_types18.default.oneOfType([import_prop_types18.default.number, import_prop_types18.default.string])
  }),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types18.default.oneOfType([import_prop_types18.default.object, import_prop_types18.default.string]),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types18.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types18.default.shape({
    bottom: import_prop_types18.default.number,
    left: import_prop_types18.default.number,
    right: import_prop_types18.default.number,
    top: import_prop_types18.default.number
  }),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types18.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types18.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types18.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types18.default.oneOfType([import_prop_types18.default.object, import_prop_types18.default.string]),
  /**
   * The series to display in the bar chart.
   * An array of [[HeatmapSeriesType]] objects.
   */
  series: import_prop_types18.default.arrayOf(import_prop_types18.default.object).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types18.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types18.default.object,
  sx: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.func, import_prop_types18.default.object, import_prop_types18.default.bool])), import_prop_types18.default.func, import_prop_types18.default.object]),
  title: import_prop_types18.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   */
  tooltip: import_prop_types18.default.shape({
    axisContent: import_prop_types18.default.elementType,
    classes: import_prop_types18.default.object,
    itemContent: import_prop_types18.default.elementType,
    slotProps: import_prop_types18.default.object,
    slots: import_prop_types18.default.object,
    trigger: import_prop_types18.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types18.default.oneOfType([import_prop_types18.default.object, import_prop_types18.default.string]),
  viewBox: import_prop_types18.default.shape({
    height: import_prop_types18.default.number,
    width: import_prop_types18.default.number,
    x: import_prop_types18.default.number,
    y: import_prop_types18.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types18.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types18.default.arrayOf(import_prop_types18.default.shape({
    barGapRatio: import_prop_types18.default.number,
    categoryGapRatio: import_prop_types18.default.number,
    classes: import_prop_types18.default.object,
    colorMap: import_prop_types18.default.oneOfType([import_prop_types18.default.shape({
      colors: import_prop_types18.default.arrayOf(import_prop_types18.default.string).isRequired,
      type: import_prop_types18.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types18.default.string,
      values: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number, import_prop_types18.default.string]).isRequired)
    }), import_prop_types18.default.shape({
      color: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.string.isRequired), import_prop_types18.default.func]).isRequired,
      max: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
      min: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
      type: import_prop_types18.default.oneOf(["continuous"]).isRequired
    }), import_prop_types18.default.shape({
      colors: import_prop_types18.default.arrayOf(import_prop_types18.default.string).isRequired,
      thresholds: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]).isRequired).isRequired,
      type: import_prop_types18.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types18.default.array,
    dataKey: import_prop_types18.default.string,
    disableLine: import_prop_types18.default.bool,
    disableTicks: import_prop_types18.default.bool,
    fill: import_prop_types18.default.string,
    hideTooltip: import_prop_types18.default.bool,
    id: import_prop_types18.default.oneOfType([import_prop_types18.default.number, import_prop_types18.default.string]),
    label: import_prop_types18.default.string,
    labelFontSize: import_prop_types18.default.number,
    labelStyle: import_prop_types18.default.object,
    max: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
    min: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
    position: import_prop_types18.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types18.default.bool,
    scaleType: import_prop_types18.default.oneOf(["band"]),
    slotProps: import_prop_types18.default.object,
    slots: import_prop_types18.default.object,
    stroke: import_prop_types18.default.string,
    sx: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.func, import_prop_types18.default.object, import_prop_types18.default.bool])), import_prop_types18.default.func, import_prop_types18.default.object]),
    tickFontSize: import_prop_types18.default.number,
    tickInterval: import_prop_types18.default.oneOfType([import_prop_types18.default.oneOf(["auto"]), import_prop_types18.default.array, import_prop_types18.default.func]),
    tickLabelInterval: import_prop_types18.default.oneOfType([import_prop_types18.default.oneOf(["auto"]), import_prop_types18.default.func]),
    tickLabelPlacement: import_prop_types18.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types18.default.object,
    tickMaxStep: import_prop_types18.default.number,
    tickMinStep: import_prop_types18.default.number,
    tickNumber: import_prop_types18.default.number,
    tickPlacement: import_prop_types18.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types18.default.number,
    valueFormatter: import_prop_types18.default.func,
    zoom: import_prop_types18.default.oneOfType([import_prop_types18.default.shape({
      filterMode: import_prop_types18.default.oneOf(["discard", "keep"]),
      maxEnd: import_prop_types18.default.number,
      maxSpan: import_prop_types18.default.number,
      minSpan: import_prop_types18.default.number,
      minStart: import_prop_types18.default.number,
      panning: import_prop_types18.default.bool,
      step: import_prop_types18.default.number
    }), import_prop_types18.default.bool])
  })).isRequired,
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types18.default.arrayOf(import_prop_types18.default.shape({
    barGapRatio: import_prop_types18.default.number,
    categoryGapRatio: import_prop_types18.default.number,
    classes: import_prop_types18.default.object,
    colorMap: import_prop_types18.default.oneOfType([import_prop_types18.default.shape({
      colors: import_prop_types18.default.arrayOf(import_prop_types18.default.string).isRequired,
      type: import_prop_types18.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types18.default.string,
      values: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number, import_prop_types18.default.string]).isRequired)
    }), import_prop_types18.default.shape({
      color: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.string.isRequired), import_prop_types18.default.func]).isRequired,
      max: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
      min: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
      type: import_prop_types18.default.oneOf(["continuous"]).isRequired
    }), import_prop_types18.default.shape({
      colors: import_prop_types18.default.arrayOf(import_prop_types18.default.string).isRequired,
      thresholds: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]).isRequired).isRequired,
      type: import_prop_types18.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types18.default.array,
    dataKey: import_prop_types18.default.string,
    disableLine: import_prop_types18.default.bool,
    disableTicks: import_prop_types18.default.bool,
    fill: import_prop_types18.default.string,
    hideTooltip: import_prop_types18.default.bool,
    id: import_prop_types18.default.oneOfType([import_prop_types18.default.number, import_prop_types18.default.string]),
    label: import_prop_types18.default.string,
    labelFontSize: import_prop_types18.default.number,
    labelStyle: import_prop_types18.default.object,
    max: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
    min: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
    position: import_prop_types18.default.oneOf(["left", "right"]),
    reverse: import_prop_types18.default.bool,
    scaleType: import_prop_types18.default.oneOf(["band"]),
    slotProps: import_prop_types18.default.object,
    slots: import_prop_types18.default.object,
    stroke: import_prop_types18.default.string,
    sx: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.func, import_prop_types18.default.object, import_prop_types18.default.bool])), import_prop_types18.default.func, import_prop_types18.default.object]),
    tickFontSize: import_prop_types18.default.number,
    tickInterval: import_prop_types18.default.oneOfType([import_prop_types18.default.oneOf(["auto"]), import_prop_types18.default.array, import_prop_types18.default.func]),
    tickLabelInterval: import_prop_types18.default.oneOfType([import_prop_types18.default.oneOf(["auto"]), import_prop_types18.default.func]),
    tickLabelPlacement: import_prop_types18.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types18.default.object,
    tickMaxStep: import_prop_types18.default.number,
    tickMinStep: import_prop_types18.default.number,
    tickNumber: import_prop_types18.default.number,
    tickPlacement: import_prop_types18.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types18.default.number,
    valueFormatter: import_prop_types18.default.func,
    zoom: import_prop_types18.default.oneOfType([import_prop_types18.default.shape({
      filterMode: import_prop_types18.default.oneOf(["discard", "keep"]),
      maxEnd: import_prop_types18.default.number,
      maxSpan: import_prop_types18.default.number,
      minSpan: import_prop_types18.default.number,
      minStart: import_prop_types18.default.number,
      panning: import_prop_types18.default.bool,
      step: import_prop_types18.default.number
    }), import_prop_types18.default.bool])
  })).isRequired,
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types18.default.arrayOf(import_prop_types18.default.shape({
    colorMap: import_prop_types18.default.oneOfType([import_prop_types18.default.shape({
      colors: import_prop_types18.default.arrayOf(import_prop_types18.default.string).isRequired,
      type: import_prop_types18.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types18.default.string,
      values: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number, import_prop_types18.default.string]).isRequired)
    }), import_prop_types18.default.shape({
      color: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.string.isRequired), import_prop_types18.default.func]).isRequired,
      max: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
      min: import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]),
      type: import_prop_types18.default.oneOf(["continuous"]).isRequired
    }), import_prop_types18.default.shape({
      colors: import_prop_types18.default.arrayOf(import_prop_types18.default.string).isRequired,
      thresholds: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.instanceOf(Date), import_prop_types18.default.number]).isRequired).isRequired,
      type: import_prop_types18.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types18.default.array,
    dataKey: import_prop_types18.default.string,
    id: import_prop_types18.default.string,
    max: import_prop_types18.default.number,
    min: import_prop_types18.default.number
  }))
} : void 0;
export {
  DefaultHeatmapTooltip,
  Heatmap,
  HeatmapPlot,
  getHeatmapUtilityClass,
  heatmapClasses
};
//# sourceMappingURL=@mui_x-charts-pro_Heatmap.js.map
